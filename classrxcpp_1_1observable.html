<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RxCpp: rxcpp::observable&lt; T, SourceOperator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RxCpp
   </div>
   <div id="projectbrief">The Reactive Extensions for Native (RxCpp) is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators in both C and C++.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerxcpp.html">rxcpp</a></li><li class="navelem"><a class="el" href="classrxcpp_1_1observable.html">observable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classrxcpp_1_1observable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rxcpp::observable&lt; T, SourceOperator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__group-observable.html">Observables</a> &#124; <a class="el" href="group__group-core.html">Basics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>a source of values. subscribe or use one of the operator methods that return a new observable, which uses this observable as a source.  
 <a href="classrxcpp_1_1observable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rx-observable_8hpp_source.html">rx-observable.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rxcpp::observable&lt; T, SourceOperator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrxcpp_1_1observable__inherit__graph.png" border="0" usemap="#rxcpp_1_1observable_3_01_t_00_01_source_operator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="rxcpp_1_1observable_3_01_t_00_01_source_operator_01_4_inherit__map" id="rxcpp_1_1observable_3_01_t_00_01_source_operator_01_4_inherit__map">
<area shape="rect" id="node3" href="classrxcpp_1_1connectable__observable.html" title="a source of values that is shared across all subscribers and does not start until connectable_observa..." alt="" coords="441,5,663,46"/>
<area shape="rect" id="node4" href="classrxcpp_1_1grouped__observable.html" title="a source of observables which each emit values from one category specified by the key selector..." alt="" coords="463,70,641,111"/>
<area shape="rect" id="node2" href="structrxcpp_1_1observable__base.html" title="rxcpp::observable_base\&lt; T \&gt;" alt="" coords="5,45,197,72"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rxcpp::observable&lt; T, SourceOperator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classrxcpp_1_1observable__coll__graph.png" border="0" usemap="#rxcpp_1_1observable_3_01_t_00_01_source_operator_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="rxcpp_1_1observable_3_01_t_00_01_source_operator_01_4_coll__map" id="rxcpp_1_1observable_3_01_t_00_01_source_operator_01_4_coll__map">
<area shape="rect" id="node2" href="structrxcpp_1_1observable__base.html" title="rxcpp::observable_base\&lt; T \&gt;" alt="" coords="5,5,197,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acc65011f4be0645074fce6e3ffa55183"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacerxcpp_1_1util.html#a330332ad1e8f1df0c04a14cfe986343a">rxu::decay_t</a>&lt; SourceOperator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#acc65011f4be0645074fce6e3ffa55183">source_operator_type</a></td></tr>
<tr class="separator:acc65011f4be0645074fce6e3ffa55183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7611ae2cb7a27ce34b0eb8acb008713f"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a7611ae2cb7a27ce34b0eb8acb008713f">value_type</a></td></tr>
<tr class="separator:a7611ae2cb7a27ce34b0eb8acb008713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structrxcpp_1_1observable__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structrxcpp_1_1observable__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structrxcpp_1_1observable__base.html">rxcpp::observable_base&lt; T &gt;</a></td></tr>
<tr class="memitem:a9986076a3f96033c7aead7d98918db8a inherit pub_types_structrxcpp_1_1observable__base"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structrxcpp_1_1tag__observable.html">tag_observable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxcpp_1_1observable__base.html#a9986076a3f96033c7aead7d98918db8a">observable_tag</a></td></tr>
<tr class="separator:a9986076a3f96033c7aead7d98918db8a inherit pub_types_structrxcpp_1_1observable__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcae97b5340e977f39a8f6965508fcc2 inherit pub_types_structrxcpp_1_1observable__base"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxcpp_1_1observable__base.html#afcae97b5340e977f39a8f6965508fcc2">value_type</a></td></tr>
<tr class="separator:afcae97b5340e977f39a8f6965508fcc2 inherit pub_types_structrxcpp_1_1observable__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0ffadbf511c0cc11e49037557b1dffb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a0ffadbf511c0cc11e49037557b1dffb8">~observable</a> ()</td></tr>
<tr class="separator:a0ffadbf511c0cc11e49037557b1dffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154ab5e07d035fffd5c07dc69361ca55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a154ab5e07d035fffd5c07dc69361ca55">observable</a> ()</td></tr>
<tr class="separator:a154ab5e07d035fffd5c07dc69361ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2d00769fd0851522d9ab4507035af2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a4b2d00769fd0851522d9ab4507035af2">observable</a> (const <a class="el" href="classrxcpp_1_1observable.html#acc65011f4be0645074fce6e3ffa55183">source_operator_type</a> &amp;o)</td></tr>
<tr class="separator:a4b2d00769fd0851522d9ab4507035af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce9431e8ce2428d685b4db936b99b4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a5ce9431e8ce2428d685b4db936b99b4d">observable</a> (<a class="el" href="classrxcpp_1_1observable.html#acc65011f4be0645074fce6e3ffa55183">source_operator_type</a> &amp;&amp;o)</td></tr>
<tr class="separator:a5ce9431e8ce2428d685b4db936b99b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd04971e48f33318dee59e75371cbd3"><td class="memTemplParams" colspan="2">template&lt;class SO &gt; </td></tr>
<tr class="memitem:a0cd04971e48f33318dee59e75371cbd3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a0cd04971e48f33318dee59e75371cbd3">observable</a> (const <a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; T, SO &gt; &amp;o)</td></tr>
<tr class="memdesc:a0cd04971e48f33318dee59e75371cbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">implicit conversion between observables of the same value_type  <a href="#a0cd04971e48f33318dee59e75371cbd3">More...</a><br /></td></tr>
<tr class="separator:a0cd04971e48f33318dee59e75371cbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fddc4afd25c5d970cfdf064723c490a"><td class="memTemplParams" colspan="2">template&lt;class SO &gt; </td></tr>
<tr class="memitem:a9fddc4afd25c5d970cfdf064723c490a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a9fddc4afd25c5d970cfdf064723c490a">observable</a> (<a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; T, SO &gt; &amp;&amp;o)</td></tr>
<tr class="memdesc:a9fddc4afd25c5d970cfdf064723c490a"><td class="mdescLeft">&#160;</td><td class="mdescRight">implicit conversion between observables of the same value_type  <a href="#a9fddc4afd25c5d970cfdf064723c490a">More...</a><br /></td></tr>
<tr class="separator:a9fddc4afd25c5d970cfdf064723c490a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647b2cb235851e27c1e9d029af3893ba"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a647b2cb235851e27c1e9d029af3893ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a647b2cb235851e27c1e9d029af3893ba">as_dynamic</a> (AN **...) const </td></tr>
<tr class="separator:a647b2cb235851e27c1e9d029af3893ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ef8a400c97f4a9a0827abede3af526"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ac2ef8a400c97f4a9a0827abede3af526"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrxcpp_1_1blocking__observable.html">blocking_observable</a>&lt; T, <a class="el" href="classrxcpp_1_1observable.html">this_type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a> (AN **...) const </td></tr>
<tr class="separator:ac2ef8a400c97f4a9a0827abede3af526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee091cb373e1c0d392b2b2d208cedfda"><td class="memTemplParams" colspan="2">template&lt;class... ArgN&gt; </td></tr>
<tr class="memitem:aee091cb373e1c0d392b2b2d208cedfda"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a> (ArgN &amp;&amp;...an) const  -&gt; <a class="el" href="classrxcpp_1_1composite__subscription.html">composite_subscription</a></td></tr>
<tr class="memdesc:aee091cb373e1c0d392b2b2d208cedfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe will cause the source observable to emit values to the provided subscriber.  <a href="#aee091cb373e1c0d392b2b2d208cedfda">More...</a><br /></td></tr>
<tr class="separator:aee091cb373e1c0d392b2b2d208cedfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7b4d8ef6969a1a3e3503ca08b7aef6"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a5a7b4d8ef6969a1a3e3503ca08b7aef6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a5a7b4d8ef6969a1a3e3503ca08b7aef6">all</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a5a7b4d8ef6969a1a3e3503ca08b7aef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Observable that emits true if every item emitted by the source Observable satisfies a specified condition, otherwise false. Emits true if the source Observable terminates without emitting any item.  <a href="#a5a7b4d8ef6969a1a3e3503ca08b7aef6">More...</a><br /></td></tr>
<tr class="separator:a5a7b4d8ef6969a1a3e3503ca08b7aef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ab13d5fdc2f350cd8065ac5152b431"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a44ab13d5fdc2f350cd8065ac5152b431"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a44ab13d5fdc2f350cd8065ac5152b431">is_empty</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a44ab13d5fdc2f350cd8065ac5152b431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Observable that emits true if the source Observable is empty, otherwise false.  <a href="#a44ab13d5fdc2f350cd8065ac5152b431">More...</a><br /></td></tr>
<tr class="separator:a44ab13d5fdc2f350cd8065ac5152b431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae7c152d44253b5c73f9fe00d7c298b"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a1ae7c152d44253b5c73f9fe00d7c298b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a1ae7c152d44253b5c73f9fe00d7c298b">any</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a1ae7c152d44253b5c73f9fe00d7c298b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Observable that emits true if any item emitted by the source Observable satisfies a specified condition, otherwise false. Emits false if the source Observable terminates without emitting any item.  <a href="#a1ae7c152d44253b5c73f9fe00d7c298b">More...</a><br /></td></tr>
<tr class="separator:a1ae7c152d44253b5c73f9fe00d7c298b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a18903a6eb3d3f788be5683a9fac6e"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a88a18903a6eb3d3f788be5683a9fac6e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a88a18903a6eb3d3f788be5683a9fac6e">exists</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a88a18903a6eb3d3f788be5683a9fac6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Observable that emits true if any item emitted by the source Observable satisfies a specified condition, otherwise false. Emits false if the source Observable terminates without emitting any item.  <a href="#a88a18903a6eb3d3f788be5683a9fac6e">More...</a><br /></td></tr>
<tr class="separator:a88a18903a6eb3d3f788be5683a9fac6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae168cea8c957ec4ebde4aeb567de067a"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ae168cea8c957ec4ebde4aeb567de067a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ae168cea8c957ec4ebde4aeb567de067a">contains</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ae168cea8c957ec4ebde4aeb567de067a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Observable that emits true if the source Observable emitted a specified item, otherwise false. Emits false if the source Observable terminates without emitting any item.  <a href="#ae168cea8c957ec4ebde4aeb567de067a">More...</a><br /></td></tr>
<tr class="separator:ae168cea8c957ec4ebde4aeb567de067a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a90fd428f1b037c01836713c581ab58"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a2a90fd428f1b037c01836713c581ab58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a2a90fd428f1b037c01836713c581ab58">filter</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a2a90fd428f1b037c01836713c581ab58"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use Predicate to select which items to emit from the new observable that is returned.  <a href="#a2a90fd428f1b037c01836713c581ab58">More...</a><br /></td></tr>
<tr class="separator:a2a90fd428f1b037c01836713c581ab58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e261cbdb809940b0248a1fbcbd5ef87"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a0e261cbdb809940b0248a1fbcbd5ef87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a0e261cbdb809940b0248a1fbcbd5ef87">switch_if_empty</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a0e261cbdb809940b0248a1fbcbd5ef87"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the source Observable terminates without emitting any items, emits items from a backup Observable.  <a href="#a0e261cbdb809940b0248a1fbcbd5ef87">More...</a><br /></td></tr>
<tr class="separator:a0e261cbdb809940b0248a1fbcbd5ef87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95cd0f3338ca2e92af55af04a03552c"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ad95cd0f3338ca2e92af55af04a03552c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ad95cd0f3338ca2e92af55af04a03552c">default_if_empty</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ad95cd0f3338ca2e92af55af04a03552c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the source Observable terminates without emitting any items, emits a default item and completes.  <a href="#ad95cd0f3338ca2e92af55af04a03552c">More...</a><br /></td></tr>
<tr class="separator:ad95cd0f3338ca2e92af55af04a03552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac85bbfc4fa1aa7ca30564a96822eca7"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:aac85bbfc4fa1aa7ca30564a96822eca7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#aac85bbfc4fa1aa7ca30564a96822eca7">sequence_equal</a> (AN...an) const </td></tr>
<tr class="memdesc:aac85bbfc4fa1aa7ca30564a96822eca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two Observables emit the same sequence of items.  <a href="#aac85bbfc4fa1aa7ca30564a96822eca7">More...</a><br /></td></tr>
<tr class="separator:aac85bbfc4fa1aa7ca30564a96822eca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2109684f61f248de266b8df1ad5fbb"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:abf2109684f61f248de266b8df1ad5fbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#abf2109684f61f248de266b8df1ad5fbb">tap</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:abf2109684f61f248de266b8df1ad5fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">inspect calls to on_next, on_error and on_completed.  <a href="#abf2109684f61f248de266b8df1ad5fbb">More...</a><br /></td></tr>
<tr class="separator:abf2109684f61f248de266b8df1ad5fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72044b2d3e68179cc88379173edb24f2"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a72044b2d3e68179cc88379173edb24f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a72044b2d3e68179cc88379173edb24f2">time_interval</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a72044b2d3e68179cc88379173edb24f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an observable that emits indications of the amount of time lapsed between consecutive emissions of the source observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item.  <a href="#a72044b2d3e68179cc88379173edb24f2">More...</a><br /></td></tr>
<tr class="separator:a72044b2d3e68179cc88379173edb24f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18651c2dbe6c603e6f7f53389ee4176"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ac18651c2dbe6c603e6f7f53389ee4176"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ac18651c2dbe6c603e6f7f53389ee4176">timeout</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ac18651c2dbe6c603e6f7f53389ee4176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that terminates with <a class="el" href="classrxcpp_1_1timeout__error.html">timeout_error</a> if a particular timespan has passed without emitting another item from the source observable.  <a href="#ac18651c2dbe6c603e6f7f53389ee4176">More...</a><br /></td></tr>
<tr class="separator:ac18651c2dbe6c603e6f7f53389ee4176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3dcda85c609a5006fa1707da5ae3d7"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a5b3dcda85c609a5006fa1707da5ae3d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a5b3dcda85c609a5006fa1707da5ae3d7">timestamp</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a5b3dcda85c609a5006fa1707da5ae3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an observable that attaches a timestamp to each item emitted by the source observable indicating when it was emitted.  <a href="#a5b3dcda85c609a5006fa1707da5ae3d7">More...</a><br /></td></tr>
<tr class="separator:a5b3dcda85c609a5006fa1707da5ae3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bb3d14a7d4f02273504e674ec4a13e"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ac5bb3d14a7d4f02273504e674ec4a13e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ac5bb3d14a7d4f02273504e674ec4a13e">finally</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ac5bb3d14a7d4f02273504e674ec4a13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new action at the end of the new observable that is returned.  <a href="#ac5bb3d14a7d4f02273504e674ec4a13e">More...</a><br /></td></tr>
<tr class="separator:ac5bb3d14a7d4f02273504e674ec4a13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55183eba74706e04b912f592d677f1d8"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a55183eba74706e04b912f592d677f1d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a55183eba74706e04b912f592d677f1d8">on_error_resume_next</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a55183eba74706e04b912f592d677f1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an error occurs, take the result from the Selector and subscribe to that instead.  <a href="#a55183eba74706e04b912f592d677f1d8">More...</a><br /></td></tr>
<tr class="separator:a55183eba74706e04b912f592d677f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5def992d37a760cec74223df3155525"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ae5def992d37a760cec74223df3155525"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ae5def992d37a760cec74223df3155525">switch_on_error</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ae5def992d37a760cec74223df3155525"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an error occurs, take the result from the Selector and subscribe to that instead.  <a href="#ae5def992d37a760cec74223df3155525">More...</a><br /></td></tr>
<tr class="separator:ae5def992d37a760cec74223df3155525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6098a8e2412f51c87b01d098278a1e6"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ab6098a8e2412f51c87b01d098278a1e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ab6098a8e2412f51c87b01d098278a1e6">map</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ab6098a8e2412f51c87b01d098278a1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use Selector to produce an item to emit from the new observable that is returned.  <a href="#ab6098a8e2412f51c87b01d098278a1e6">More...</a><br /></td></tr>
<tr class="separator:ab6098a8e2412f51c87b01d098278a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284866ee1ffad7f10a006922ca7f41fa"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a284866ee1ffad7f10a006922ca7f41fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a284866ee1ffad7f10a006922ca7f41fa">transform</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a284866ee1ffad7f10a006922ca7f41fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use Selector to produce an item to emit from the new observable that is returned.  <a href="#a284866ee1ffad7f10a006922ca7f41fa">More...</a><br /></td></tr>
<tr class="separator:a284866ee1ffad7f10a006922ca7f41fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7985d77b81bd90194d698fa8d3eb7ad3"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a7985d77b81bd90194d698fa8d3eb7ad3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a7985d77b81bd90194d698fa8d3eb7ad3">debounce</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a7985d77b81bd90194d698fa8d3eb7ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits an item if a particular timespan has passed without emitting another item from the source observable.  <a href="#a7985d77b81bd90194d698fa8d3eb7ad3">More...</a><br /></td></tr>
<tr class="separator:a7985d77b81bd90194d698fa8d3eb7ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84f545169079c6400874b941653698b"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ad84f545169079c6400874b941653698b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ad84f545169079c6400874b941653698b">delay</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ad84f545169079c6400874b941653698b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits each item emitted by the source observable after the specified delay.  <a href="#ad84f545169079c6400874b941653698b">More...</a><br /></td></tr>
<tr class="separator:ad84f545169079c6400874b941653698b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8362ca3c509db8960fe783716c867f1d"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a8362ca3c509db8960fe783716c867f1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a8362ca3c509db8960fe783716c867f1d">distinct</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a8362ca3c509db8960fe783716c867f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable, filter out repeated values and emit only items that have not already been emitted.  <a href="#a8362ca3c509db8960fe783716c867f1d">More...</a><br /></td></tr>
<tr class="separator:a8362ca3c509db8960fe783716c867f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1c480f4a0d5082aebe0aee226ab63a"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a3a1c480f4a0d5082aebe0aee226ab63a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a3a1c480f4a0d5082aebe0aee226ab63a">distinct_until_changed</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a3a1c480f4a0d5082aebe0aee226ab63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable, filter out consequentially repeated values and emit only changes from the new observable that is returned.  <a href="#a3a1c480f4a0d5082aebe0aee226ab63a">More...</a><br /></td></tr>
<tr class="separator:a3a1c480f4a0d5082aebe0aee226ab63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8011cef457e8db5a59226be7980f9f9"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ab8011cef457e8db5a59226be7980f9f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ab8011cef457e8db5a59226be7980f9f9">element_at</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ab8011cef457e8db5a59226be7980f9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulls an item located at a specified index location in the sequence of items and emits that item as its own sole emission.  <a href="#ab8011cef457e8db5a59226be7980f9f9">More...</a><br /></td></tr>
<tr class="separator:ab8011cef457e8db5a59226be7980f9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca631f7a8a5c197c825c6d4281ac6a3e"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:aca631f7a8a5c197c825c6d4281ac6a3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:aca631f7a8a5c197c825c6d4281ac6a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits connected, non-overlapping windows, each containing at most count items from the source observable. If the skip parameter is set, return an observable that emits windows every skip items containing at most count items from the source observable.  <a href="#aca631f7a8a5c197c825c6d4281ac6a3e">More...</a><br /></td></tr>
<tr class="separator:aca631f7a8a5c197c825c6d4281ac6a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156fe8c091615a81f153266cf2288e00"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a156fe8c091615a81f153266cf2288e00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a156fe8c091615a81f153266cf2288e00">window_with_time</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a156fe8c091615a81f153266cf2288e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits observables every period time interval and collects items from this observable for period of time into each produced observable, on the specified scheduler. If the skip parameter is set, return an observable that emits observables every skip time interval and collects items from this observable for period of time into each produced observable, on the specified scheduler.  <a href="#a156fe8c091615a81f153266cf2288e00">More...</a><br /></td></tr>
<tr class="separator:a156fe8c091615a81f153266cf2288e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd61243ac469723f00c88827ed94f43f"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:acd61243ac469723f00c88827ed94f43f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#acd61243ac469723f00c88827ed94f43f">window_with_time_or_count</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:acd61243ac469723f00c88827ed94f43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits connected, non-overlapping windows of items from the source observable that were emitted during a fixed duration of time or when the window has reached maximum capacity (whichever occurs first), on the specified scheduler.  <a href="#acd61243ac469723f00c88827ed94f43f">More...</a><br /></td></tr>
<tr class="separator:acd61243ac469723f00c88827ed94f43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c299105748ab694bb3decc83f2b02d"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a87c299105748ab694bb3decc83f2b02d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a87c299105748ab694bb3decc83f2b02d">window_toggle</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a87c299105748ab694bb3decc83f2b02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits observables every period time interval and collects items from this observable for period of time into each produced observable, on the specified scheduler.  <a href="#a87c299105748ab694bb3decc83f2b02d">More...</a><br /></td></tr>
<tr class="separator:a87c299105748ab694bb3decc83f2b02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c01d55af12fd801b093de144ff35aa7"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a4c01d55af12fd801b093de144ff35aa7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a4c01d55af12fd801b093de144ff35aa7">buffer</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a4c01d55af12fd801b093de144ff35aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits connected, non-overlapping buffer, each containing at most count items from the source observable. If the skip parameter is set, return an observable that emits buffers every skip items containing at most count items from the source observable.  <a href="#a4c01d55af12fd801b093de144ff35aa7">More...</a><br /></td></tr>
<tr class="separator:a4c01d55af12fd801b093de144ff35aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3e1164c0962ca3d137d9f1d01b07a5"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a5c3e1164c0962ca3d137d9f1d01b07a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a5c3e1164c0962ca3d137d9f1d01b07a5">buffer_with_time</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a5c3e1164c0962ca3d137d9f1d01b07a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits buffers every period time interval and collects items from this observable for period of time into each produced buffer. If the skip parameter is set, Return an observable that emits buffers every skip time interval and collects items from this observable for period of time into each produced buffer, on the specified scheduler.  <a href="#a5c3e1164c0962ca3d137d9f1d01b07a5">More...</a><br /></td></tr>
<tr class="separator:a5c3e1164c0962ca3d137d9f1d01b07a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f577d709bef58e8d65bfa0ed03b139"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a54f577d709bef58e8d65bfa0ed03b139"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a54f577d709bef58e8d65bfa0ed03b139">buffer_with_time_or_count</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a54f577d709bef58e8d65bfa0ed03b139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits connected, non-overlapping buffers of items from the source observable that were emitted during a fixed duration of time or when the buffer has reached maximum capacity (whichever occurs first), on the specified scheduler.  <a href="#a54f577d709bef58e8d65bfa0ed03b139">More...</a><br /></td></tr>
<tr class="separator:a54f577d709bef58e8d65bfa0ed03b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47284539a10abb57c63caa6ad05c4b86"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a47284539a10abb57c63caa6ad05c4b86"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a47284539a10abb57c63caa6ad05c4b86">switch_on_next</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a47284539a10abb57c63caa6ad05c4b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return observable that emits the items emitted by the observable most recently emitted by the source observable.  <a href="#a47284539a10abb57c63caa6ad05c4b86">More...</a><br /></td></tr>
<tr class="separator:a47284539a10abb57c63caa6ad05c4b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278b7eca33afc119ff6dc30bf70e7a78"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a278b7eca33afc119ff6dc30bf70e7a78"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a278b7eca33afc119ff6dc30bf70e7a78">merge</a> (AN...an) const </td></tr>
<tr class="memdesc:a278b7eca33afc119ff6dc30bf70e7a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each given observable subscribe. For each item emitted from all of the given observables, deliver from the new observable that is returned.  <a href="#a278b7eca33afc119ff6dc30bf70e7a78">More...</a><br /></td></tr>
<tr class="separator:a278b7eca33afc119ff6dc30bf70e7a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3b69b33291457c68bd3760137bd515"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a5a3b69b33291457c68bd3760137bd515"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a5a3b69b33291457c68bd3760137bd515">amb</a> (AN...an) const </td></tr>
<tr class="memdesc:a5a3b69b33291457c68bd3760137bd515"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from only the first of the given observables deliver from the new observable that is returned, on the specified scheduler.  <a href="#a5a3b69b33291457c68bd3760137bd515">More...</a><br /></td></tr>
<tr class="separator:a5a3b69b33291457c68bd3760137bd515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1195b083ffa5a97fb1deb854c1e9bee"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ab1195b083ffa5a97fb1deb854c1e9bee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee">flat_map</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ab1195b083ffa5a97fb1deb854c1e9bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use the CollectionSelector to produce an observable and subscribe to that observable. For each item from all of the produced observables use the ResultSelector to produce a value to emit from the new observable that is returned.  <a href="#ab1195b083ffa5a97fb1deb854c1e9bee">More...</a><br /></td></tr>
<tr class="separator:ab1195b083ffa5a97fb1deb854c1e9bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc307f7e12e46db1b6a1d95b7bdf3777"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:afc307f7e12e46db1b6a1d95b7bdf3777"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#afc307f7e12e46db1b6a1d95b7bdf3777">merge_transform</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:afc307f7e12e46db1b6a1d95b7bdf3777"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use the CollectionSelector to produce an observable and subscribe to that observable. For each item from all of the produced observables use the ResultSelector to produce a value to emit from the new observable that is returned.  <a href="#afc307f7e12e46db1b6a1d95b7bdf3777">More...</a><br /></td></tr>
<tr class="separator:afc307f7e12e46db1b6a1d95b7bdf3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3041ca26a53f2912dd15cde6e3422d07"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a3041ca26a53f2912dd15cde6e3422d07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a> (AN...an) const </td></tr>
<tr class="memdesc:a3041ca26a53f2912dd15cde6e3422d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable subscribe to one at a time, in the order received. For each item from all of the given observables deliver from the new observable that is returned.  <a href="#a3041ca26a53f2912dd15cde6e3422d07">More...</a><br /></td></tr>
<tr class="separator:a3041ca26a53f2912dd15cde6e3422d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a01456840d6acd1ad61359acf6a738"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ad0a01456840d6acd1ad61359acf6a738"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ad0a01456840d6acd1ad61359acf6a738">concat_map</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ad0a01456840d6acd1ad61359acf6a738"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use the CollectionSelector to produce an observable and subscribe to that observable. For each item from all of the produced observables use the ResultSelector to produce a value to emit from the new observable that is returned.  <a href="#ad0a01456840d6acd1ad61359acf6a738">More...</a><br /></td></tr>
<tr class="separator:ad0a01456840d6acd1ad61359acf6a738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bea934f6ae6c5b7bc8f22904be7094b"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a8bea934f6ae6c5b7bc8f22904be7094b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a8bea934f6ae6c5b7bc8f22904be7094b">concat_transform</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a8bea934f6ae6c5b7bc8f22904be7094b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use the CollectionSelector to produce an observable and subscribe to that observable. For each item from all of the produced observables use the ResultSelector to produce a value to emit from the new observable that is returned.  <a href="#a8bea934f6ae6c5b7bc8f22904be7094b">More...</a><br /></td></tr>
<tr class="separator:a8bea934f6ae6c5b7bc8f22904be7094b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43608a25beb6e2612429f063fb8a768b"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a43608a25beb6e2612429f063fb8a768b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a43608a25beb6e2612429f063fb8a768b">with_latest_from</a> (AN...an) const </td></tr>
<tr class="memdesc:a43608a25beb6e2612429f063fb8a768b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from the first observable select the latest value from all the observables to emit from the new observable that is returned.  <a href="#a43608a25beb6e2612429f063fb8a768b">More...</a><br /></td></tr>
<tr class="separator:a43608a25beb6e2612429f063fb8a768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7e00daa1d31af32d88cfdaa1dd8e70"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:aeb7e00daa1d31af32d88cfdaa1dd8e70"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#aeb7e00daa1d31af32d88cfdaa1dd8e70">combine_latest</a> (AN...an) const </td></tr>
<tr class="memdesc:aeb7e00daa1d31af32d88cfdaa1dd8e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from all of the observables select a value to emit from the new observable that is returned.  <a href="#aeb7e00daa1d31af32d88cfdaa1dd8e70">More...</a><br /></td></tr>
<tr class="separator:aeb7e00daa1d31af32d88cfdaa1dd8e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883540dae084f6c0aff3c5396448d4ea"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a883540dae084f6c0aff3c5396448d4ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a883540dae084f6c0aff3c5396448d4ea">zip</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a883540dae084f6c0aff3c5396448d4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bring by one item from all given observables and select a value to emit from the new observable that is returned.  <a href="#a883540dae084f6c0aff3c5396448d4ea">More...</a><br /></td></tr>
<tr class="separator:a883540dae084f6c0aff3c5396448d4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add577ed3ce82a45b2f69c0ff34c8a668"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:add577ed3ce82a45b2f69c0ff34c8a668"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#add577ed3ce82a45b2f69c0ff34c8a668">group_by</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:add577ed3ce82a45b2f69c0ff34c8a668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an observable that emits grouped_observables, each of which corresponds to a unique key value and each of which emits those items from the source observable that share that key value.  <a href="#add577ed3ce82a45b2f69c0ff34c8a668">More...</a><br /></td></tr>
<tr class="separator:add577ed3ce82a45b2f69c0ff34c8a668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d29197dc2b5939507e719dd16820ede"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a1d29197dc2b5939507e719dd16820ede"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a1d29197dc2b5939507e719dd16820ede">ignore_elements</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a1d29197dc2b5939507e719dd16820ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not emit any items from the source Observable, but allow termination notification (either onError or onCompleted) to pass through unchanged.  <a href="#a1d29197dc2b5939507e719dd16820ede">More...</a><br /></td></tr>
<tr class="separator:a1d29197dc2b5939507e719dd16820ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7312ee6b988b30c82cca3a5e68855ea2"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a7312ee6b988b30c82cca3a5e68855ea2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a7312ee6b988b30c82cca3a5e68855ea2">multicast</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="separator:a7312ee6b988b30c82cca3a5e68855ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cda439be2f5fe2c14d828fab60c894"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a11cda439be2f5fe2c14d828fab60c894"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a11cda439be2f5fe2c14d828fab60c894">publish</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a11cda439be2f5fe2c14d828fab60c894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a cold observable hot and allow connections to the source to be independent of subscriptions. Turn a cold observable hot, send the most recent value to any new subscriber, and allow connections to the source to be independent of subscriptions.  <a href="#a11cda439be2f5fe2c14d828fab60c894">More...</a><br /></td></tr>
<tr class="separator:a11cda439be2f5fe2c14d828fab60c894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df5bfc80004d2e46360a75aa9e418b8"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a2df5bfc80004d2e46360a75aa9e418b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a2df5bfc80004d2e46360a75aa9e418b8">publish_synchronized</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a2df5bfc80004d2e46360a75aa9e418b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a cold observable hot and allow connections to the source to be independent of subscriptions.  <a href="#a2df5bfc80004d2e46360a75aa9e418b8">More...</a><br /></td></tr>
<tr class="separator:a2df5bfc80004d2e46360a75aa9e418b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb26338385e6fa3d3a3cce2df32e948"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:afbb26338385e6fa3d3a3cce2df32e948"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:afbb26338385e6fa3d3a3cce2df32e948"><td class="mdescLeft">&#160;</td><td class="mdescRight">1) replay(optional Coordination, optional CompositeSubscription) Turn a cold observable hot, send all earlier emitted values to any new subscriber, and allow connections to the source to be independent of subscriptions.  <a href="#afbb26338385e6fa3d3a3cce2df32e948">More...</a><br /></td></tr>
<tr class="separator:afbb26338385e6fa3d3a3cce2df32e948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225ad69622b7c80328bae63232de84b6"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a225ad69622b7c80328bae63232de84b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a225ad69622b7c80328bae63232de84b6">subscribe_on</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a225ad69622b7c80328bae63232de84b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscription and unsubscription are queued and delivered using the scheduler from the supplied coordination.  <a href="#a225ad69622b7c80328bae63232de84b6">More...</a><br /></td></tr>
<tr class="separator:a225ad69622b7c80328bae63232de84b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe2255f4f5b3517d615583ae7085148"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:abbe2255f4f5b3517d615583ae7085148"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#abbe2255f4f5b3517d615583ae7085148">observe_on</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:abbe2255f4f5b3517d615583ae7085148"><td class="mdescLeft">&#160;</td><td class="mdescRight">All values are queued and delivered using the scheduler from the supplied coordination.  <a href="#abbe2255f4f5b3517d615583ae7085148">More...</a><br /></td></tr>
<tr class="separator:abbe2255f4f5b3517d615583ae7085148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb7300bc8a57cfbd3b5c8033102a983"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a8cb7300bc8a57cfbd3b5c8033102a983"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a8cb7300bc8a57cfbd3b5c8033102a983"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use Accumulator to combine items, when completed use ResultSelector to produce a value that will be emitted from the new observable that is returned.  <a href="#a8cb7300bc8a57cfbd3b5c8033102a983">More...</a><br /></td></tr>
<tr class="separator:a8cb7300bc8a57cfbd3b5c8033102a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb48e2c6f72ef76502353d4f9356a680"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:aeb48e2c6f72ef76502353d4f9356a680"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#aeb48e2c6f72ef76502353d4f9356a680">accumulate</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:aeb48e2c6f72ef76502353d4f9356a680"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use Accumulator to combine items, when completed use ResultSelector to produce a value that will be emitted from the new observable that is returned.  <a href="#aeb48e2c6f72ef76502353d4f9356a680">More...</a><br /></td></tr>
<tr class="separator:aeb48e2c6f72ef76502353d4f9356a680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1991f48cddc52ab002cd21af7b5ebd5d"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a1991f48cddc52ab002cd21af7b5ebd5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a1991f48cddc52ab002cd21af7b5ebd5d">first</a> (AN **...) const </td></tr>
<tr class="memdesc:a1991f48cddc52ab002cd21af7b5ebd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable reduce it by sending only the first item.  <a href="#a1991f48cddc52ab002cd21af7b5ebd5d">More...</a><br /></td></tr>
<tr class="separator:a1991f48cddc52ab002cd21af7b5ebd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71e47ee8ea52772e576bffb94f58006"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:aa71e47ee8ea52772e576bffb94f58006"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#aa71e47ee8ea52772e576bffb94f58006">last</a> (AN **...) const </td></tr>
<tr class="memdesc:aa71e47ee8ea52772e576bffb94f58006"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable reduce it by sending only the last item.  <a href="#aa71e47ee8ea52772e576bffb94f58006">More...</a><br /></td></tr>
<tr class="separator:aa71e47ee8ea52772e576bffb94f58006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9451593d64584ef6c80f74d04d1c8d4"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ad9451593d64584ef6c80f74d04d1c8d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ad9451593d64584ef6c80f74d04d1c8d4">count</a> (AN **...) const </td></tr>
<tr class="memdesc:ad9451593d64584ef6c80f74d04d1c8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable reduce it by incrementing a count.  <a href="#ad9451593d64584ef6c80f74d04d1c8d4">More...</a><br /></td></tr>
<tr class="separator:ad9451593d64584ef6c80f74d04d1c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2089aff58d5757a11bd11e10915b5a87"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a2089aff58d5757a11bd11e10915b5a87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a2089aff58d5757a11bd11e10915b5a87">sum</a> (AN **...) const </td></tr>
<tr class="memdesc:a2089aff58d5757a11bd11e10915b5a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable reduce it by adding to the previous items.  <a href="#a2089aff58d5757a11bd11e10915b5a87">More...</a><br /></td></tr>
<tr class="separator:a2089aff58d5757a11bd11e10915b5a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9083a6c8884c526f8180ac24741bf9b8"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a9083a6c8884c526f8180ac24741bf9b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a9083a6c8884c526f8180ac24741bf9b8">average</a> (AN **...) const </td></tr>
<tr class="memdesc:a9083a6c8884c526f8180ac24741bf9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable reduce it by adding to the previous values and then dividing by the number of items at the end.  <a href="#a9083a6c8884c526f8180ac24741bf9b8">More...</a><br /></td></tr>
<tr class="separator:a9083a6c8884c526f8180ac24741bf9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfa719cf263a2494b4cbe4b2662faee"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:afcfa719cf263a2494b4cbe4b2662faee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#afcfa719cf263a2494b4cbe4b2662faee">max</a> (AN **...) const </td></tr>
<tr class="memdesc:afcfa719cf263a2494b4cbe4b2662faee"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable reduce it by taking the max value of the previous items.  <a href="#afcfa719cf263a2494b4cbe4b2662faee">More...</a><br /></td></tr>
<tr class="separator:afcfa719cf263a2494b4cbe4b2662faee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a1bbeca10e00e1ae152fb73141021c"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a07a1bbeca10e00e1ae152fb73141021c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a07a1bbeca10e00e1ae152fb73141021c">min</a> (AN **...) const </td></tr>
<tr class="memdesc:a07a1bbeca10e00e1ae152fb73141021c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable reduce it by taking the min value of the previous items.  <a href="#a07a1bbeca10e00e1ae152fb73141021c">More...</a><br /></td></tr>
<tr class="separator:a07a1bbeca10e00e1ae152fb73141021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62939b867fda18e9d04dd7267bc67ac7"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a62939b867fda18e9d04dd7267bc67ac7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a62939b867fda18e9d04dd7267bc67ac7">scan</a> (AN...an) const </td></tr>
<tr class="memdesc:a62939b867fda18e9d04dd7267bc67ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable use Accumulator to combine items into a value that will be emitted from the new observable that is returned.  <a href="#a62939b867fda18e9d04dd7267bc67ac7">More...</a><br /></td></tr>
<tr class="separator:a62939b867fda18e9d04dd7267bc67ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2fc988b96239a31ed85d8161a031e4"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a4f2fc988b96239a31ed85d8161a031e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a4f2fc988b96239a31ed85d8161a031e4">sample_with_time</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:a4f2fc988b96239a31ed85d8161a031e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an Observable that emits the most recent items emitted by the source Observable within periodic time intervals.  <a href="#a4f2fc988b96239a31ed85d8161a031e4">More...</a><br /></td></tr>
<tr class="separator:a4f2fc988b96239a31ed85d8161a031e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5283adf7187df741a8a22d7bd73d270a"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a5283adf7187df741a8a22d7bd73d270a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a> (AN...an) const </td></tr>
<tr class="memdesc:a5283adf7187df741a8a22d7bd73d270a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make new observable with skipped first count items from this observable.  <a href="#a5283adf7187df741a8a22d7bd73d270a">More...</a><br /></td></tr>
<tr class="separator:a5283adf7187df741a8a22d7bd73d270a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a0c932a49d082c0280a2c4a332d423"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:aa8a0c932a49d082c0280a2c4a332d423"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#aa8a0c932a49d082c0280a2c4a332d423">skip_last</a> (AN...an) const </td></tr>
<tr class="memdesc:aa8a0c932a49d082c0280a2c4a332d423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make new observable with skipped last count items from this observable.  <a href="#aa8a0c932a49d082c0280a2c4a332d423">More...</a><br /></td></tr>
<tr class="separator:aa8a0c932a49d082c0280a2c4a332d423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa14f5212a960591df205ea76a7b37"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a6faa14f5212a960591df205ea76a7b37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a6faa14f5212a960591df205ea76a7b37">skip_until</a> (AN...an) const </td></tr>
<tr class="memdesc:a6faa14f5212a960591df205ea76a7b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make new observable with items skipped until on_next occurs on the trigger observable or until the specified time. skip_until takes (TriggerObservable, optional Coordination) or (TimePoint, optional Coordination)  <a href="#a6faa14f5212a960591df205ea76a7b37">More...</a><br /></td></tr>
<tr class="separator:a6faa14f5212a960591df205ea76a7b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b375948c452baf1e3854823b7d398de"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a0b375948c452baf1e3854823b7d398de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a> (AN...an) const </td></tr>
<tr class="memdesc:a0b375948c452baf1e3854823b7d398de"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the first count items from this observable emit them from the new observable that is returned.  <a href="#a0b375948c452baf1e3854823b7d398de">More...</a><br /></td></tr>
<tr class="separator:a0b375948c452baf1e3854823b7d398de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbac14434778d0b139006da8738043dc"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:acbac14434778d0b139006da8738043dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#acbac14434778d0b139006da8738043dc">take_last</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:acbac14434778d0b139006da8738043dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit only the final t items emitted by the source Observable.  <a href="#acbac14434778d0b139006da8738043dc">More...</a><br /></td></tr>
<tr class="separator:acbac14434778d0b139006da8738043dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaecad9e5470ce8acf7f6119ae0d0f5"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:acdaecad9e5470ce8acf7f6119ae0d0f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#acdaecad9e5470ce8acf7f6119ae0d0f5">take_until</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:acdaecad9e5470ce8acf7f6119ae0d0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each item from this observable until on_next occurs on the trigger observable or until the specified time, emit them from the new observable that is returned. take_until takes (TriggerObservable, optional Coordination) or (TimePoint, optional Coordination)  <a href="#acdaecad9e5470ce8acf7f6119ae0d0f5">More...</a><br /></td></tr>
<tr class="separator:acdaecad9e5470ce8acf7f6119ae0d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac553cf73ea02b79abf5d7db6e60a2cbb"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:ac553cf73ea02b79abf5d7db6e60a2cbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ac553cf73ea02b79abf5d7db6e60a2cbb">take_while</a> (AN &amp;&amp;...an) const </td></tr>
<tr class="memdesc:ac553cf73ea02b79abf5d7db6e60a2cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the first items fulfilling the predicate from this observable emit them from the new observable that is returned.  <a href="#ac553cf73ea02b79abf5d7db6e60a2cbb">More...</a><br /></td></tr>
<tr class="separator:ac553cf73ea02b79abf5d7db6e60a2cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af189a03bfcd06ab654a6ec8bb4941474"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:af189a03bfcd06ab654a6ec8bb4941474"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#af189a03bfcd06ab654a6ec8bb4941474">repeat</a> (AN...an) const </td></tr>
<tr class="memdesc:af189a03bfcd06ab654a6ec8bb4941474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat this observable for the given number of times or infinitely.  <a href="#af189a03bfcd06ab654a6ec8bb4941474">More...</a><br /></td></tr>
<tr class="separator:af189a03bfcd06ab654a6ec8bb4941474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c3de11d01b74bf73553cc932688136"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a68c3de11d01b74bf73553cc932688136"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a68c3de11d01b74bf73553cc932688136">retry</a> (AN...an) const </td></tr>
<tr class="memdesc:a68c3de11d01b74bf73553cc932688136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retry this observable for the given number of times.  <a href="#a68c3de11d01b74bf73553cc932688136">More...</a><br /></td></tr>
<tr class="separator:a68c3de11d01b74bf73553cc932688136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84801c399e8407d904efb3e51206adb3"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a84801c399e8407d904efb3e51206adb3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a84801c399e8407d904efb3e51206adb3">start_with</a> (AN...an) const </td></tr>
<tr class="memdesc:a84801c399e8407d904efb3e51206adb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start with the supplied values, then concatenate this observable.  <a href="#a84801c399e8407d904efb3e51206adb3">More...</a><br /></td></tr>
<tr class="separator:a84801c399e8407d904efb3e51206adb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28636f8a78edee595b623560f828c88b"><td class="memTemplParams" colspan="2">template&lt;class... AN&gt; </td></tr>
<tr class="memitem:a28636f8a78edee595b623560f828c88b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a28636f8a78edee595b623560f828c88b">pairwise</a> (AN...an) const </td></tr>
<tr class="memdesc:a28636f8a78edee595b623560f828c88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take values pairwise from this observable.  <a href="#a28636f8a78edee595b623560f828c88b">More...</a><br /></td></tr>
<tr class="separator:a28636f8a78edee595b623560f828c88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7b75fd3cc1b1a2885ac04abaf9b9733b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrxcpp_1_1observable.html#acc65011f4be0645074fce6e3ffa55183">source_operator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#a7b75fd3cc1b1a2885ac04abaf9b9733b">source_operator</a></td></tr>
<tr class="separator:a7b75fd3cc1b1a2885ac04abaf9b9733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:acc2477d3e61a348c9d584e655cdefc7b"><td class="memTemplParams" colspan="2">template&lt;class U , class SO &gt; </td></tr>
<tr class="memitem:acc2477d3e61a348c9d584e655cdefc7b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#acc2477d3e61a348c9d584e655cdefc7b">observable</a></td></tr>
<tr class="separator:acc2477d3e61a348c9d584e655cdefc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b848fa96296bc6772e673cba3869f9"><td class="memTemplParams" colspan="2">template&lt;class U , class SO &gt; </td></tr>
<tr class="memitem:ae9b848fa96296bc6772e673cba3869f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrxcpp_1_1observable.html#ae9b848fa96296bc6772e673cba3869f9">operator==</a> (const <a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; U, SO &gt; &amp;, const <a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; U, SO &gt; &amp;)</td></tr>
<tr class="separator:ae9b848fa96296bc6772e673cba3869f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class SourceOperator&gt;<br />
class rxcpp::observable&lt; T, SourceOperator &gt;</h3>

<p>a source of values. subscribe or use one of the operator methods that return a new observable, which uses this observable as a source. </p>
<dl class="section user"><dt>Some code</dt><dd>This sample will <a class="el" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda" title="Subscribe will cause the source observable to emit values to the provided subscriber. ">observable::subscribe()</a> to values from a <a class="el" href="classrxcpp_1_1observable_3_01void_00_01void_01_4.html#a1a8f97d5e438fe47b3c85776e89bc9f0" title="Returns an observable that sends values in the range first-last by adding step to the previous value...">observable&lt;void, void&gt;::range()</a>.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 5);</div><div class="line">    values1.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="acc65011f4be0645074fce6e3ffa55183"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacerxcpp_1_1util.html#a330332ad1e8f1df0c04a14cfe986343a">rxu::decay_t</a>&lt;SourceOperator&gt; <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::<a class="el" href="classrxcpp_1_1observable.html#acc65011f4be0645074fce6e3ffa55183">source_operator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7611ae2cb7a27ce34b0eb8acb008713f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::<a class="el" href="classrxcpp_1_1observable.html#a7611ae2cb7a27ce34b0eb8acb008713f">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0ffadbf511c0cc11e49037557b1dffb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::~<a class="el" href="classrxcpp_1_1observable.html">observable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a154ab5e07d035fffd5c07dc69361ca55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::<a class="el" href="classrxcpp_1_1observable.html">observable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b2d00769fd0851522d9ab4507035af2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::<a class="el" href="classrxcpp_1_1observable.html">observable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrxcpp_1_1observable.html#acc65011f4be0645074fce6e3ffa55183">source_operator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ce9431e8ce2428d685b4db936b99b4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::<a class="el" href="classrxcpp_1_1observable.html">observable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrxcpp_1_1observable.html#acc65011f4be0645074fce6e3ffa55183">source_operator_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0cd04971e48f33318dee59e75371cbd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class SO &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::<a class="el" href="classrxcpp_1_1observable.html">observable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; T, SO &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implicit conversion between observables of the same value_type </p>

</div>
</div>
<a class="anchor" id="a9fddc4afd25c5d970cfdf064723c490a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class SO &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::<a class="el" href="classrxcpp_1_1observable.html">observable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; T, SO &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implicit conversion between observables of the same value_type </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aeb48e2c6f72ef76502353d4f9356a680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::accumulate </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use Accumulator to combine items, when completed use ResultSelector to produce a value that will be emitted from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Seed</td><td>the type of the initial value for the accumulator </td></tr>
    <tr><td class="paramname">Accumulator</td><td>the type of the data accumulating function </td></tr>
    <tr><td class="paramname">ResultSelector</td><td>the type of the result producing function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the initial value for the accumulator </td></tr>
    <tr><td class="paramname">a</td><td>an accumulator function to be invoked on each item emitted by the source observable, the result of which will be used in the next accumulator call </td></tr>
    <tr><td class="paramname">rs</td><td>a result producing function that makes the final value from the last accumulator call result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits a single item that is the result of accumulating the output from the items emitted by the source observable.</dd></dl>
<p>Some basic reduce-type operators have already been implemented:</p><ul>
<li><a class="el" href="namespacerxcpp_1_1operators.html#ac19a7a29ca5be51edbcd7c7d4482e048" title="For each item from this observable reduce it by sending only the first item. ">rxcpp::operators::first</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a84e276fcb6e305b3139b4c8cb9edb3ac" title="For each item from this observable reduce it by sending only the last item. ">rxcpp::operators::last</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a0f074d4712deb435a74ab5890a8108fa" title="For each item from this observable reduce it by incrementing a count. ">rxcpp::operators::count</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#ae58d3cf6a72f64a261918a745a64beb6" title="For each item from this observable reduce it by adding to the previous items. ">rxcpp::operators::sum</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a2798e0ee0ee6b53efae26b60f1d18f4c" title="For each item from this observable reduce it by adding to the previous values and then dividing by th...">rxcpp::operators::average</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a419caaea34eea86b9951205a32b26348" title="For each item from this observable reduce it by taking the min value of the previous items...">rxcpp::operators::min</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a574e80abbc68529816f47cb0bcaa97d6" title="For each item from this observable reduce it by taking the max value of the previous items...">rxcpp::operators::max</a></li>
</ul>
<dl class="section user"><dt>Sample Code</dt><dd>Geometric mean of source values: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a>(</div><div class="line">            std::make_pair(0, 1.0),</div><div class="line">            [](std::pair&lt;int, double&gt; seed, <span class="keywordtype">int</span> v){</div><div class="line">                seed.first += 1;</div><div class="line">                seed.second *= v;</div><div class="line">                <span class="keywordflow">return</span> seed;</div><div class="line">            },</div><div class="line">            [](std::pair&lt;int, double&gt; res){</div><div class="line">                <span class="keywordflow">return</span> std::pow(res.second, 1.0 / res.first);</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 3.380015</div><div class="line">OnCompleted</div></div><!-- fragment --> If the source observable completes without emitting any items, the resulting observable emits the result of passing the initial seed to the result selector: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a>(</div><div class="line">            1,</div><div class="line">            [](<span class="keywordtype">int</span>,<span class="keywordtype">int</span>){<span class="keywordflow">return</span> 0;},</div><div class="line">            [](<span class="keywordtype">int</span> res){<span class="keywordflow">return</span> res;});</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnCompleted</div></div><!-- fragment --> If the accumulator raises an exception, it is returned by the resulting observable in on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a>(</div><div class="line">            0,</div><div class="line">            [](<span class="keywordtype">int</span> seed, <span class="keywordtype">int</span> v){</div><div class="line">                <span class="keywordflow">if</span> (v == 2)</div><div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Exception from accumulator&quot;</span>);</div><div class="line">                <span class="keywordflow">return</span> seed;</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> res){<span class="keywordflow">return</span> res;});</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Exception <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> accumulator</div></div><!-- fragment --> The same for exceptions raised by the result selector: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a>(</div><div class="line">            0,</div><div class="line">            [](<span class="keywordtype">int</span> seed, <span class="keywordtype">int</span> v){<span class="keywordflow">return</span> seed + v;},</div><div class="line">            [](<span class="keywordtype">int</span> res){</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Exception from result selector&quot;</span>);</div><div class="line">                <span class="keywordflow">return</span> res;</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Exception <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> result selector</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a5a7b4d8ef6969a1a3e3503ca08b7aef6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::all </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Observable that emits true if every item emitted by the source Observable satisfies a specified condition, otherwise false. Emits true if the source Observable terminates without emitting any item. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>the type of the test function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the test function to test items emitted by the source Observable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits true if every item emitted by the source observable satisfies a specified condition, otherwise false.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 3, 4, 5).all([](<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> n &lt; 6; });</div><div class="line">    values.</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">bool</span> v) { printf(<span class="stringliteral">&quot;OnNext: %s\n&quot;</span>, v ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: <span class="keyword">true</span></div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a5a3b69b33291457c68bd3760137bd515"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::amb </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from only the first of the given observables deliver from the new observable that is returned, on the specified scheduler. </p>
<p>There are 2 variants of the operator:</p><ul>
<li>The source observable emits nested observables, one of the nested observables is selected.</li>
<li>The source observable and the arguments v0...vn are used to provide the observables to select from.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional). </td></tr>
    <tr><td class="paramname">Value0</td><td>... (optional). </td></tr>
    <tr><td class="paramname">ValueN</td><td>types of source observables (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>the scheduler to synchronize sources from different contexts (optional). </td></tr>
    <tr><td class="paramname">v0</td><td>... (optional). </td></tr>
    <tr><td class="paramname">vn</td><td>source observables (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the same sequence as whichever of the source observables first emitted an item or sent a termination notification.</dd></dl>
<p>If scheduler is omitted, identity_current_thread is used.</p>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(15)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer1 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer2 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(5)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer3 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 3;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> base = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(o1.as_dynamic(), o2, o3);</div><div class="line">    <span class="keyword">auto</span> values = base.amb(<a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481294776064] Timer3 fired</div><div class="line">[thread 47481294776064] OnNext: 3</div><div class="line">[thread 47481294776064] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(15)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 1;});</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 2;});</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(5)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 3;});</div><div class="line">    <span class="keyword">auto</span> base = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(o1.as_dynamic(), o2, o3);</div><div class="line">    <span class="keyword">auto</span> values = base.<a class="code" href="classrxcpp_1_1observable.html#a5a3b69b33291457c68bd3760137bd515">amb</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --> <div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(15)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 1;});</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 2;});</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(5)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 3;});</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#a5a3b69b33291457c68bd3760137bd515">amb</a>(o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --> <div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(15)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer1 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer2 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(5)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer3 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 3;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#a5a3b69b33291457c68bd3760137bd515">amb</a>(<a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>(), o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481294776064] Timer3 fired</div><div class="line">[thread 47481294776064] OnNext: 3</div><div class="line">[thread 47481294776064] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a1ae7c152d44253b5c73f9fe00d7c298b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::any </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Observable that emits true if any item emitted by the source Observable satisfies a specified condition, otherwise false. Emits false if the source Observable terminates without emitting any item. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>the type of the test function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the test function to test items emitted by the source Observable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits true if any item emitted by the source observable satisfies a specified condition, otherwise false.</dd></dl>
<p>Some basic any- operators have already been implemented:</p><ul>
<li><a class="el" href="namespacerxcpp_1_1operators.html#adaf4940d2694d8977acef843976d2b69" title="Returns an Observable that emits true if any item emitted by the source Observable satisfies a specif...">rxcpp::operators::exists</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a026043bc4a67cca57ae088c4d07c4b79" title="Returns an Observable that emits true if the source Observable emitted a specified item...">rxcpp::operators::contains</a></li>
</ul>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 3, 4, 5).exists([](<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> n &gt; 3; });</div><div class="line">    values.</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">bool</span> v) { printf(<span class="stringliteral">&quot;OnNext: %s\n&quot;</span>, v ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: <span class="keyword">true</span></div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 3, 4, 5).contains(3);</div><div class="line">    values.</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">bool</span> v) { printf(<span class="stringliteral">&quot;OnNext: %s\n&quot;</span>, v ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: <span class="keyword">true</span></div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ac2ef8a400c97f4a9a0827abede3af526"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1blocking__observable.html">blocking_observable</a>&lt;T, <a class="el" href="classrxcpp_1_1observable.html">this_type</a>&gt; <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::as_blocking </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a new observable that contains the blocking methods for this observable.</p>
<dl class="section return"><dt>Returns</dt><dd>An observable that contains the blocking methods for this observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(<a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>(), 1, 2, 3).map([](<span class="keywordtype">int</span> v){</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Emit value: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481303181056] Emit value: 1</div><div class="line">[thread 47481303181056] OnNext: 1</div><div class="line">[thread 47481303181056] Emit value: 2</div><div class="line">[thread 47481303181056] OnNext: 2</div><div class="line">[thread 47481303181056] Emit value: 3</div><div class="line">[thread 47481303181056] OnNext: 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a647b2cb235851e27c1e9d029af3893ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt;T&gt; <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::as_dynamic </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a new observable that performs type-forgetting conversion of this observable.</p>
<dl class="section return"><dt>Returns</dt><dd>The source observable converted to observable&lt;T&gt;.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operator could be useful to workaround lambda deduction bug on msvc 2013.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a801daa2d18ecb5fb28be86732a40e57a">rxcpp::observable&lt;&gt;::just</a>(4);</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;();</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(o2, o3);</div><div class="line">    printf(<span class="stringliteral">&quot;type of o1:                  %s\n&quot;</span>, <span class="keyword">typeid</span>(o1).name());</div><div class="line">    printf(<span class="stringliteral">&quot;type of o1.as_dynamic():     %s\n&quot;</span>, <span class="keyword">typeid</span>(o1.as_dynamic()).name());</div><div class="line">    printf(<span class="stringliteral">&quot;type of o2:                  %s\n&quot;</span>, <span class="keyword">typeid</span>(o2).name());</div><div class="line">    printf(<span class="stringliteral">&quot;type of o2.as_dynamic():     %s\n&quot;</span>, <span class="keyword">typeid</span>(o2.as_dynamic()).name());</div><div class="line">    printf(<span class="stringliteral">&quot;type of o3:                  %s\n&quot;</span>, <span class="keyword">typeid</span>(o3).name());</div><div class="line">    printf(<span class="stringliteral">&quot;type of o3.as_dynamic():     %s\n&quot;</span>, <span class="keyword">typeid</span>(o3.as_dynamic()).name());</div><div class="line">    printf(<span class="stringliteral">&quot;type of values:              %s\n&quot;</span>, <span class="keyword">typeid</span>(values).name());</div><div class="line">    printf(<span class="stringliteral">&quot;type of values.as_dynamic(): %s\n&quot;</span>, <span class="keyword">typeid</span>(values.<a class="code" href="classrxcpp_1_1observable.html#a647b2cb235851e27c1e9d029af3893ba">as_dynamic</a>()).name());</div></div><!-- fragment --><div class="fragment"><div class="line">type of o1:                  N5rxcpp10observableIiNS_7sources6detail5rangeIiNS_19identity_one_workerEEEEE</div><div class="line">type of o1.as_dynamic():     N5rxcpp10observableIiNS_18dynamic_observableIiEEEE</div><div class="line">type of o2:                  N5rxcpp10observableIiNS_7sources6detail7iterateINSt3__15arrayIiLm1EEENS_19identity_one_workerEEEEE</div><div class="line">type of o2.as_dynamic():     N5rxcpp10observableIiNS_18dynamic_observableIiEEEE</div><div class="line">type of o3:                  N5rxcpp10observableIiNS_7sources6detail7iterateINSt3__15arrayIiLm0EEENS_19identity_one_workerEEEEE</div><div class="line">type of o3.as_dynamic():     N5rxcpp10observableIiNS_18dynamic_observableIiEEEE</div><div class="line">type of values:              N5rxcpp10observableIiNS_9operators6detail6concatINS0_IiNS_18dynamic_observableIiEEEENS0_IS6_NS4_IS6_EEEENS_19identity_one_workerEEEEE</div><div class="line">type of values.<a class="code" href="classrxcpp_1_1observable.html#a647b2cb235851e27c1e9d029af3893ba">as_dynamic</a>(): N5rxcpp10observableIiNS_18dynamic_observableIiEEEE</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a9083a6c8884c526f8180ac24741bf9b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::average </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable reduce it by adding to the previous values and then dividing by the number of items at the end. </p>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits a single item: the average of elements emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 4).average();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 2.500000</div><div class="line">OnCompleted</div></div><!-- fragment --> When the source observable completes without emitting any items: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;().<a class="code" href="classrxcpp_1_1observable.html#a9083a6c8884c526f8180ac24741bf9b8">average</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1empty__error.html">rxcpp::empty_error</a>&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: <a class="code" href="classrxcpp_1_1observable.html#a9083a6c8884c526f8180ac24741bf9b8">average</a>() requires a stream with at least one value</div></div><!-- fragment --> When the source observable calls on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 4).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a9083a6c8884c526f8180ac24741bf9b8">average</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a4c01d55af12fd801b093de144ff35aa7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits connected, non-overlapping buffer, each containing at most count items from the source observable. If the skip parameter is set, return an observable that emits buffers every skip items containing at most count items from the source observable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the maximum size of each buffers before it should be emitted. </td></tr>
    <tr><td class="paramname">skip</td><td>how many items need to be skipped before starting a new buffers (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits connected, non-overlapping buffers, each containing at most count items from the source observable. If the skip parameter is set, return an Observable that emits buffers every skip items containing at most count items from the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 5).buffer(2);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::vector&lt;int&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">int</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %d&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 2</div><div class="line">OnNext: 3 4</div><div class="line">OnNext: 5</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).buffer(2, 3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::vector&lt;int&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">int</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %d&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 2</div><div class="line">OnNext: 4 5</div><div class="line">OnNext: 7</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a5c3e1164c0962ca3d137d9f1d01b07a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::buffer_with_time </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits buffers every period time interval and collects items from this observable for period of time into each produced buffer. If the skip parameter is set, Return an observable that emits buffers every skip time interval and collects items from this observable for period of time into each produced buffer, on the specified scheduler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of the time interval </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the period of time each buffer collects items before it is emitted. </td></tr>
    <tr><td class="paramname">skip</td><td>the period of time after which a new buffer will be created (optional). </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler for the buffers (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits buffers every period time interval and collect items from this observable for period of time into each produced buffer. If the skip parameter is set, return an Observable that emits buffers every skip time interval and collect items from this observable for period of time into each produced buffer.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> period = std::chrono::milliseconds(4);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a> = std::chrono::milliseconds(6);</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab6098a8e2412f51c87b01d098278a1e6">map</a>([](<span class="keywordtype">long</span> v){</div><div class="line">            printf(<span class="stringliteral">&quot;[thread %s] Interval OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">            <span class="keywordflow">return</span> v;</div><div class="line">        }).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a5c3e1164c0962ca3d137d9f1d01b07a5">buffer_with_time</a>(period, <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a>, <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::vector&lt;long&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] OnNext:&quot;</span>, get_pid().c_str());</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">long</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %ld&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Interval OnNext: 1</div><div class="line">[thread 47481267428736] Interval OnNext: 2</div><div class="line">[thread 47481294776064] OnNext: 1 2</div><div class="line">[thread 47481267428736] Interval OnNext: 3</div><div class="line">[thread 47481267428736] Interval OnNext: 4</div><div class="line">[thread 47481267428736] Interval OnNext: 5</div><div class="line">[thread 47481294776064] OnNext: 4 5</div><div class="line">[thread 47481267428736] Interval OnNext: 6</div><div class="line">[thread 47481267428736] Interval OnNext: 7</div><div class="line">[thread 47481294776064] OnNext: 7</div><div class="line">[thread 47481294776064] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> period = std::chrono::milliseconds(4);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a> = std::chrono::milliseconds(6);</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a5c3e1164c0962ca3d137d9f1d01b07a5">buffer_with_time</a>(period, <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a>);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::vector&lt;long&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">long</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %ld&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 2</div><div class="line">OnNext: 4 5</div><div class="line">OnNext: 7</div><div class="line">OnCompleted</div></div><!-- fragment --> Overlapping buffers are allowed: <div class="fragment"><div class="line">    <span class="keyword">auto</span> period = std::chrono::milliseconds(6);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a> = std::chrono::milliseconds(4);</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a5c3e1164c0962ca3d137d9f1d01b07a5">buffer_with_time</a>(period, <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a>);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::vector&lt;long&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">long</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %ld&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 2 3</div><div class="line">OnNext: 3 4 5</div><div class="line">OnNext: 5 6 7</div><div class="line">OnNext: 7</div><div class="line">OnCompleted</div></div><!-- fragment --> If no items are emitted, an empty buffer is returned: <div class="fragment"><div class="line">    <span class="keyword">auto</span> period = std::chrono::milliseconds(2);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a> = std::chrono::milliseconds(4);</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a5c3e1164c0962ca3d137d9f1d01b07a5">buffer_with_time</a>(period, <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a>);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::vector&lt;long&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">long</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %ld&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext:</div><div class="line">OnNext:</div><div class="line">OnNext: 1</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a5c3e1164c0962ca3d137d9f1d01b07a5">buffer_with_time</a>(std::chrono::milliseconds(4), <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::vector&lt;long&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">long</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %ld&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 2</div><div class="line">OnNext: 3 4</div><div class="line">OnNext: 5 6</div><div class="line">OnNext: 7</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a5c3e1164c0962ca3d137d9f1d01b07a5">buffer_with_time</a>(std::chrono::milliseconds(4));</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::vector&lt;long&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">long</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %ld&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 2</div><div class="line">OnNext: 3 4</div><div class="line">OnNext: 5 6</div><div class="line">OnNext: 7</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a54f577d709bef58e8d65bfa0ed03b139"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::buffer_with_time_or_count </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits connected, non-overlapping buffers of items from the source observable that were emitted during a fixed duration of time or when the buffer has reached maximum capacity (whichever occurs first), on the specified scheduler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of the time interval. </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the period of time each buffer collects items before it is emitted and replaced with a new buffer. </td></tr>
    <tr><td class="paramname">count</td><td>the maximum size of each buffer before it is emitted and new buffer is created. </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler for the buffers (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits connected, non-overlapping buffers of items from the source observable that were emitted during a fixed duration of time or when the buffer has reached maximum capacity (whichever occurs first).</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div><div class="line">    <span class="keyword">auto</span> int1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1L, 3L);</div><div class="line">    <span class="keyword">auto</span> int2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(50));</div><div class="line">    <span class="keyword">auto</span> values = int1.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(int2).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a54f577d709bef58e8d65bfa0ed03b139">buffer_with_time_or_count</a>(std::chrono::milliseconds(20), 2, <a class="code" href="namespacerxcpp.html#abada901083087bcaa013508558643f41">rxcpp::observe_on_event_loop</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [start](std::vector&lt;long&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">long</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %ld&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 2</div><div class="line">OnNext: 3</div><div class="line">OnNext:</div><div class="line">OnNext: 1</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div><div class="line">    <span class="keyword">auto</span> int1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1L, 3L);</div><div class="line">    <span class="keyword">auto</span> int2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(50));</div><div class="line">    <span class="keyword">auto</span> values = int1.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(int2).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a54f577d709bef58e8d65bfa0ed03b139">buffer_with_time_or_count</a>(std::chrono::milliseconds(20), 2);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [start](std::vector&lt;long&gt; v){</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext:&quot;</span>);</div><div class="line">                std::for_each(v.begin(), v.end(), [](<span class="keywordtype">long</span> a){</div><div class="line">                    printf(<span class="stringliteral">&quot; %ld&quot;</span>, a);</div><div class="line">                });</div><div class="line">                printf(<span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 2</div><div class="line">OnNext: 3</div><div class="line">OnNext:</div><div class="line">OnNext: 1</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="aeb7e00daa1d31af32d88cfdaa1dd8e70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::combine_latest </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from all of the observables select a value to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AN</td><td>types of scheduler (optional), aggregate function (optional), and source observables</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">an</td><td>scheduler (optional), aggregation function (optional), and source observables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits items that are the result of combining the items emitted by the source observables.</dd></dl>
<p>If scheduler is omitted, identity_current_thread is used.</p>
<p>If aggregation function is omitted, the resulting observable returns tuples of emitted items.</p>
<dl class="section user"><dt>Sample Code</dt><dd></dd></dl>
<p>Neither scheduler nor aggregation function are present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(5));</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#aeb7e00daa1d31af32d88cfdaa1dd8e70">combine_latest</a>(o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, int, int&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d, %d, %d\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v), std::get&lt;2&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1, 1, 1</div><div class="line">OnNext: 2, 1, 1</div><div class="line">OnNext: 2, 2, 1</div><div class="line">OnNext: 3, 2, 1</div><div class="line">OnNext: 3, 2, 2</div><div class="line">OnCompleted</div></div><!-- fragment --><p> Only scheduler is present: </p><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> thr = <a class="code" href="namespacerxcpp.html#a17a3a0a2d399be2c32f41f929e740c67">rxcpp::synchronize_event_loop</a>();</div><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source1 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source2 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(5)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source3 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#aeb7e00daa1d31af32d88cfdaa1dd8e70">combine_latest</a>(thr, o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, int, int&gt; v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d, %d, %d\n&quot;</span>, get_pid().c_str(), std::get&lt;0&gt;(v), std::get&lt;1&gt;(v), std::get&lt;2&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Source1 OnNext: 1</div><div class="line">[thread 47481267428736] Source2 OnNext: 1</div><div class="line">[thread 47481267428736] Source3 OnNext: 1</div><div class="line">[thread 47481298978560] OnNext: 1, 1, 1</div><div class="line">[thread 47481267428736] Source1 OnNext: 2</div><div class="line">[thread 47481298978560] OnNext: 2, 1, 1</div><div class="line">[thread 47481267428736] Source2 OnNext: 2</div><div class="line">[thread 47481298978560] OnNext: 2, 2, 1</div><div class="line">[thread 47481267428736] Source1 OnNext: 3</div><div class="line">[thread 47481298978560] OnNext: 3, 2, 1</div><div class="line">[thread 47481267428736] Source3 OnNext: 2</div><div class="line">[thread 47481298978560] OnNext: 3, 2, 2</div><div class="line">[thread 47481298978560] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --><p> Only aggregation function is present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(5));</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#aeb7e00daa1d31af32d88cfdaa1dd8e70">combine_latest</a>(</div><div class="line">        [](<span class="keywordtype">int</span> v1, <span class="keywordtype">int</span> v2, <span class="keywordtype">int</span> v3) {</div><div class="line">            <span class="keywordflow">return</span> 100 * v1 + 10 * v2 + v3;</div><div class="line">        },</div><div class="line">        o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 111</div><div class="line">OnNext: 211</div><div class="line">OnNext: 221</div><div class="line">OnNext: 321</div><div class="line">OnNext: 322</div><div class="line">OnCompleted</div></div><!-- fragment --><p> Both scheduler and aggregation function are present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(5));</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#aeb7e00daa1d31af32d88cfdaa1dd8e70">combine_latest</a>(</div><div class="line">        <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>(),</div><div class="line">        [](<span class="keywordtype">int</span> v1, <span class="keywordtype">int</span> v2, <span class="keywordtype">int</span> v3) {</div><div class="line">            <span class="keywordflow">return</span> 100 * v1 + 10 * v2 + v3;</div><div class="line">        },</div><div class="line">        o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 111</div><div class="line">OnNext: 211</div><div class="line">OnNext: 221</div><div class="line">OnNext: 321</div><div class="line">OnNext: 322</div><div class="line">OnCompleted</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3041ca26a53f2912dd15cde6e3422d07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::concat </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable subscribe to one at a time, in the order received. For each item from all of the given observables deliver from the new observable that is returned. </p>
<p>There are 2 variants of the operator:</p><ul>
<li>The source observable emits nested observables, nested observables are concatenated.</li>
<li>The source observable and the arguments v0...vn are used to provide the observables to concatenate.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional). </td></tr>
    <tr><td class="paramname">Value0</td><td>... (optional). </td></tr>
    <tr><td class="paramname">ValueN</td><td>types of source observables (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>the scheduler to synchronize sources from different contexts (optional). </td></tr>
    <tr><td class="paramname">v0</td><td>... (optional). </td></tr>
    <tr><td class="paramname">vn</td><td>source observables (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the items emitted by each of the Observables emitted by the source observable, one after the other, without interleaving them.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a801daa2d18ecb5fb28be86732a40e57a">rxcpp::observable&lt;&gt;::just</a>(4);</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(5, 6);</div><div class="line">    <span class="keyword">auto</span> base = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(o1.as_dynamic(), o2, o3);</div><div class="line">    <span class="keyword">auto</span> values = base.<a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnNext: 6</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a801daa2d18ecb5fb28be86732a40e57a">rxcpp::observable&lt;&gt;::just</a>(4);</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(5, 6);</div><div class="line">    <span class="keyword">auto</span> base = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(o1.as_dynamic(), o2, o3);</div><div class="line">    <span class="keyword">auto</span> values = base.<a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnNext: 6</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a801daa2d18ecb5fb28be86732a40e57a">rxcpp::observable&lt;&gt;::just</a>(4);</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(5, 6);</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnNext: 6</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a801daa2d18ecb5fb28be86732a40e57a">rxcpp::observable&lt;&gt;::just</a>(4);</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(5, 6);</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>(), o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnNext: 6</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ad0a01456840d6acd1ad61359acf6a738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::concat_map </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use the CollectionSelector to produce an observable and subscribe to that observable. For each item from all of the produced observables use the ResultSelector to produce a value to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CollectionSelector</td><td>the type of the observable producing function. CollectionSelector must be a function with the signature: observable(concat_map::source_value_type) </td></tr>
    <tr><td class="paramname">ResultSelector</td><td>the type of the aggregation function (optional). ResultSelector must be a function with the signature: concat_map::value_type(concat_map::source_value_type, concat_map::collection_value_type) </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a function that returns an observable for each item emitted by the source observable. </td></tr>
    <tr><td class="paramname">rs</td><td>a function that combines one item emitted by each of the source and collection observables and returns an item to be emitted by the resulting observable (optional). </td></tr>
    <tr><td class="paramname">cn</td><td>the scheduler to synchronize sources from different contexts. (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the results of applying a function to a pair of values emitted by the source observable and the collection observable.</dd></dl>
<p>Observables, produced by the CollectionSelector, are concatenated. There is another operator <a class="el" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee" title="For each item from this observable use the CollectionSelector to produce an observable and subscribe ...">rxcpp::observable&lt;T,SourceType&gt;::flat_map</a> that works similar but merges the observables.</p>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ad0a01456840d6acd1ad61359acf6a738">concat_map</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){</div><div class="line">                <span class="keywordflow">return</span></div><div class="line">                    <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(10 * v), std::chrono::milliseconds(50)).</div><div class="line">                    <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3);</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> v_main, <span class="keywordtype">long</span> v_sub){</div><div class="line">                <span class="keywordflow">return</span> std::make_tuple(v_main, v_sub);</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, long&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d - %ld\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 - 1</div><div class="line">OnNext: 1 - 2</div><div class="line">OnNext: 1 - 3</div><div class="line">OnNext: 2 - 1</div><div class="line">OnNext: 2 - 2</div><div class="line">OnNext: 2 - 3</div><div class="line">OnNext: 3 - 1</div><div class="line">OnNext: 3 - 2</div><div class="line">OnNext: 3 - 3</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ad0a01456840d6acd1ad61359acf6a738">concat_map</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] Call CollectionSelector(v = %d)\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">                <span class="keywordflow">return</span></div><div class="line">                    <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(10 * v), std::chrono::milliseconds(50)).</div><div class="line">                    <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3);</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> v_main, <span class="keywordtype">long</span> v_sub){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] Call ResultSelector(v_main = %d, v_sub = %ld)\n&quot;</span>, get_pid().c_str(), v_main, v_sub);</div><div class="line">                <span class="keywordflow">return</span> std::make_tuple(v_main, v_sub);</div><div class="line">            },</div><div class="line">            <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, long&gt; v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d - %ld\n&quot;</span>, get_pid().c_str(), std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 1)</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 1 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 1 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 1 - 3</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 2)</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 2 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 2 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 2 - 3</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 3)</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 3 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 3 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 3 - 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a8bea934f6ae6c5b7bc8f22904be7094b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::concat_transform </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use the CollectionSelector to produce an observable and subscribe to that observable. For each item from all of the produced observables use the ResultSelector to produce a value to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CollectionSelector</td><td>the type of the observable producing function. CollectionSelector must be a function with the signature: observable(concat_map::source_value_type) </td></tr>
    <tr><td class="paramname">ResultSelector</td><td>the type of the aggregation function (optional). ResultSelector must be a function with the signature: concat_map::value_type(concat_map::source_value_type, concat_map::collection_value_type) </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a function that returns an observable for each item emitted by the source observable. </td></tr>
    <tr><td class="paramname">rs</td><td>a function that combines one item emitted by each of the source and collection observables and returns an item to be emitted by the resulting observable (optional). </td></tr>
    <tr><td class="paramname">cn</td><td>the scheduler to synchronize sources from different contexts. (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the results of applying a function to a pair of values emitted by the source observable and the collection observable.</dd></dl>
<p>Observables, produced by the CollectionSelector, are concatenated. There is another operator <a class="el" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee" title="For each item from this observable use the CollectionSelector to produce an observable and subscribe ...">rxcpp::observable&lt;T,SourceType&gt;::flat_map</a> that works similar but merges the observables.</p>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ad0a01456840d6acd1ad61359acf6a738">concat_map</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){</div><div class="line">                <span class="keywordflow">return</span></div><div class="line">                    <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(10 * v), std::chrono::milliseconds(50)).</div><div class="line">                    <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3);</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> v_main, <span class="keywordtype">long</span> v_sub){</div><div class="line">                <span class="keywordflow">return</span> std::make_tuple(v_main, v_sub);</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, long&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d - %ld\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 - 1</div><div class="line">OnNext: 1 - 2</div><div class="line">OnNext: 1 - 3</div><div class="line">OnNext: 2 - 1</div><div class="line">OnNext: 2 - 2</div><div class="line">OnNext: 2 - 3</div><div class="line">OnNext: 3 - 1</div><div class="line">OnNext: 3 - 2</div><div class="line">OnNext: 3 - 3</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ad0a01456840d6acd1ad61359acf6a738">concat_map</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] Call CollectionSelector(v = %d)\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">                <span class="keywordflow">return</span></div><div class="line">                    <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(10 * v), std::chrono::milliseconds(50)).</div><div class="line">                    <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3);</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> v_main, <span class="keywordtype">long</span> v_sub){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] Call ResultSelector(v_main = %d, v_sub = %ld)\n&quot;</span>, get_pid().c_str(), v_main, v_sub);</div><div class="line">                <span class="keywordflow">return</span> std::make_tuple(v_main, v_sub);</div><div class="line">            },</div><div class="line">            <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, long&gt; v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d - %ld\n&quot;</span>, get_pid().c_str(), std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 1)</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 1 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 1 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 1 - 3</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 2)</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 2 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 2 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 2 - 3</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 3)</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 3 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 3 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 3 - 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ae168cea8c957ec4ebde4aeb567de067a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Observable that emits true if the source Observable emitted a specified item, otherwise false. Emits false if the source Observable terminates without emitting any item. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the item to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits true if the source Observable emitted a specified item, otherwise false.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 3, 4, 5).contains(3);</div><div class="line">    values.</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">bool</span> v) { printf(<span class="stringliteral">&quot;OnNext: %s\n&quot;</span>, v ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: <span class="keyword">true</span></div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ad9451593d64584ef6c80f74d04d1c8d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::count </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable reduce it by incrementing a count. </p>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits a single item: the number of elements emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).count();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --> When the source observable calls on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ad9451593d64584ef6c80f74d04d1c8d4">count</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a7985d77b81bd90194d698fa8d3eb7ad3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::debounce </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits an item if a particular timespan has passed without emitting another item from the source observable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of the time interval </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the period of time to suppress any emitted items </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler to manage timeout for each event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits an item if a particular timespan has passed without emitting another item from the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>std::chrono;</div><div class="line">    <span class="keyword">auto</span> scheduler = <a class="code" href="namespacerxcpp.html#a50575b7f31a42160e1b5a2f6c6c5827c">rxcpp::identity_current_thread</a>();</div><div class="line">    <span class="keyword">auto</span> start = scheduler.now();</div><div class="line">    <span class="keyword">auto</span> period = milliseconds(10);</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(start, period, scheduler).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(4).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a7985d77b81bd90194d698fa8d3eb7ad3">debounce</a>(period);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v) { printf(<span class="stringliteral">&quot;OnNext: %ld\n&quot;</span>, v); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 4</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ad95cd0f3338ca2e92af55af04a03552c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::default_if_empty </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the source Observable terminates without emitting any items, emits a default item and completes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value</td><td>the type of the value to emit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the default value to emit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the specified default item if the source observable is empty.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;()</div><div class="line">            .<a class="code" href="classrxcpp_1_1observable.html#ad95cd0f3338ca2e92af55af04a03552c">default_if_empty</a>(42);</div><div class="line"></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v) { printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); } );</div><div class="line"></div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 42</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ad84f545169079c6400874b941653698b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::delay </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits each item emitted by the source observable after the specified delay. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of time interval </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the period of time each item is delayed </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler for the delays</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits each item emitted by the source observable after the specified delay.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>std::chrono;</div><div class="line">    <span class="keyword">auto</span> scheduler = <a class="code" href="namespacerxcpp.html#a50575b7f31a42160e1b5a2f6c6c5827c">rxcpp::identity_current_thread</a>();</div><div class="line">    <span class="keyword">auto</span> start = scheduler.now();</div><div class="line">    <span class="keyword">auto</span> period = milliseconds(10);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> next = [=](<span class="keyword">const</span> <span class="keywordtype">char</span>* s) {</div><div class="line">        <span class="keywordflow">return</span> [=](<span class="keywordtype">long</span> v){</div><div class="line">            <span class="keyword">auto</span> t = duration_cast&lt;milliseconds&gt;(scheduler.now() - start);</div><div class="line">            <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> ms = t.count();</div><div class="line">            printf(<span class="stringliteral">&quot;[%s @ %lld] OnNext: %ld\n&quot;</span>, s, ms, v);</div><div class="line">        };</div><div class="line">    };</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(start, period, scheduler).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(4).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#abf2109684f61f248de266b8df1ad5fbb">tap</a>(next(<span class="stringliteral">&quot;interval&quot;</span>)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ad84f545169079c6400874b941653698b">delay</a>(period, <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            next(<span class="stringliteral">&quot; delayed&quot;</span>),</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">interval</a> @ 0] OnNext: 1</div><div class="line">[<a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">interval</a> @ 10] OnNext: 2</div><div class="line">[ delayed @ 10] OnNext: 1</div><div class="line">[<a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">interval</a> @ 20] OnNext: 3</div><div class="line">[ delayed @ 20] OnNext: 2</div><div class="line">[<a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">interval</a> @ 30] OnNext: 4</div><div class="line">[ delayed @ 30] OnNext: 3</div><div class="line">[ delayed @ 40] OnNext: 4</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a8362ca3c509db8960fe783716c867f1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::distinct </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable, filter out repeated values and emit only items that have not already been emitted. </p>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits those items from the source observable that are distinct.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>istinct keeps an unordered_set&lt;T&gt; of past values. Due to an issue in multiple implementations of std::hash&lt;T&gt;, rxcpp maintains a whitelist of hashable types. new types can be added by specializing rxcpp::filtered_hash&lt;T&gt;</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 2, 3, 3, 3, 4, 5, 5).distinct();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a3a1c480f4a0d5082aebe0aee226ab63a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::distinct_until_changed </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable, filter out consequentially repeated values and emit only changes from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryPredicate</td><td>(optional) the type of the value comparing function. The signature should be equivalent to the following: bool pred(const T1&amp; a, const T2&amp; b);</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>(optional) the function that implements comparison of two values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits those items from the source observable that are distinct from their immediate predecessors.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 2, 3, 3, 3, 4, 5, 5).distinct_until_changed();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ab8011cef457e8db5a59226be7980f9f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::element_at </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pulls an item located at a specified index location in the sequence of items and emits that item as its own sole emission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emit an item located at a specified index location.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).element_at(3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 4</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a88a18903a6eb3d3f788be5683a9fac6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Observable that emits true if any item emitted by the source Observable satisfies a specified condition, otherwise false. Emits false if the source Observable terminates without emitting any item. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>the type of the test function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the test function to test items emitted by the source Observable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits true if any item emitted by the source observable satisfies a specified condition, otherwise false.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 3, 4, 5).exists([](<span class="keywordtype">int</span> n) { <span class="keywordflow">return</span> n &gt; 3; });</div><div class="line">    values.</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">bool</span> v) { printf(<span class="stringliteral">&quot;OnNext: %s\n&quot;</span>, v ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: <span class="keyword">true</span></div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a2a90fd428f1b037c01836713c581ab58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use Predicate to select which items to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>the type of the filter function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the filter function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits only those items emitted by the source observable that the filter evaluates as true.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 6).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a2a90fd428f1b037c01836713c581ab58">filter</a>([](<span class="keywordtype">int</span> v){</div><div class="line">            <span class="keywordflow">return</span> v % 2;</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 3</div><div class="line">OnNext: 5</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ac5bb3d14a7d4f02273504e674ec4a13e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::finally </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new action at the end of the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LastCall</td><td>the type of the action function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lc</td><td>the action function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the same items as the source observable, then invokes the given action.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <span class="keywordflow">finally</span>([](){</div><div class="line">            printf(<span class="stringliteral">&quot;The final action\n&quot;</span>);</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnCompleted</div><div class="line">The <span class="keyword">final</span> action</div></div><!-- fragment --> If the source observable generates an error, the final action is still being called: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">        <span class="keywordflow">finally</span>([](){</div><div class="line">            printf(<span class="stringliteral">&quot;The final action\n&quot;</span>);</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div><div class="line">The <span class="keyword">final</span> action</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a1991f48cddc52ab002cd21af7b5ebd5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::first </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable reduce it by sending only the first item. </p>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits only the very first item emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).first();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnCompleted</div></div><!-- fragment --> When the source observable calls on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;().<a class="code" href="classrxcpp_1_1observable.html#a1991f48cddc52ab002cd21af7b5ebd5d">first</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1empty__error.html">rxcpp::empty_error</a>&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: <a class="code" href="classrxcpp_1_1observable.html#a1991f48cddc52ab002cd21af7b5ebd5d">first</a>() requires a stream with at least one value</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ab1195b083ffa5a97fb1deb854c1e9bee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::flat_map </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use the CollectionSelector to produce an observable and subscribe to that observable. For each item from all of the produced observables use the ResultSelector to produce a value to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CollectionSelector</td><td>the type of the observable producing function. CollectionSelector must be a function with the signature observable(flat_map::source_value_type) </td></tr>
    <tr><td class="paramname">ResultSelector</td><td>the type of the aggregation function (optional). ResultSelector must be a function with the signature flat_map::value_type(flat_map::source_value_type, flat_map::collection_value_type). </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a function that returns an observable for each item emitted by the source observable. </td></tr>
    <tr><td class="paramname">rs</td><td>a function that combines one item emitted by each of the source and collection observables and returns an item to be emitted by the resulting observable (optional). </td></tr>
    <tr><td class="paramname">cn</td><td>the scheduler to synchronize sources from different contexts (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the results of applying a function to a pair of values emitted by the source observable and the collection observable.</dd></dl>
<p>Observables, produced by the CollectionSelector, are merged. There is another operator <a class="el" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee" title="For each item from this observable use the CollectionSelector to produce an observable and subscribe ...">rxcpp::observable&lt;T,SourceType&gt;::flat_map</a> that works similar but concatenates the observables.</p>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee">flat_map</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){</div><div class="line">                <span class="keywordflow">return</span></div><div class="line">                    <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(10 * v), std::chrono::milliseconds(50)).</div><div class="line">                    <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3);</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> v_main, <span class="keywordtype">long</span> v_sub){</div><div class="line">                <span class="keywordflow">return</span> std::make_tuple(v_main, v_sub);</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, long&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d - %ld\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 - 1</div><div class="line">OnNext: 2 - 1</div><div class="line">OnNext: 3 - 1</div><div class="line">OnNext: 1 - 2</div><div class="line">OnNext: 2 - 2</div><div class="line">OnNext: 3 - 2</div><div class="line">OnNext: 1 - 3</div><div class="line">OnNext: 2 - 3</div><div class="line">OnNext: 3 - 3</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee">flat_map</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] Call CollectionSelector(v = %d)\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">                <span class="keywordflow">return</span></div><div class="line">                    <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(10 * v), std::chrono::milliseconds(50)).</div><div class="line">                    <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3);</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> v_main, <span class="keywordtype">int</span> v_sub){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] Call ResultSelector(v_main = %d, v_sub = %d)\n&quot;</span>, get_pid().c_str(), v_main, v_sub);</div><div class="line">                <span class="keywordflow">return</span> std::make_tuple(v_main, v_sub);</div><div class="line">            },</div><div class="line">            <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, long&gt; v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d - %ld\n&quot;</span>, get_pid().c_str(), std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 1)</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 2)</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 3)</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 1 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 2 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 3 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 1 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 2 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 3 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 1 - 3</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 2 - 3</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 3 - 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="add577ed3ce82a45b2f69c0ff34c8a668"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::group_by </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits grouped_observables, each of which corresponds to a unique key value and each of which emits those items from the source observable that share that key value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeySelector</td><td>the type of the key extracting function </td></tr>
    <tr><td class="paramname">MarbleSelector</td><td>the type of the element extracting function </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>the type of the key comparing function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>a function that extracts the key for each item (optional) </td></tr>
    <tr><td class="paramname">ms</td><td>a function that extracts the return element for each item (optional) </td></tr>
    <tr><td class="paramname">p</td><td>a function that implements comparison of two keys (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits values of <a class="el" href="classrxcpp_1_1grouped__observable.html" title="a source of observables which each emit values from one category specified by the key selector...">grouped_observable</a> type, each of which corresponds to a unique key value and each of which emits those items from the source observable that share that key value.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">bool</span> less(<span class="keywordtype">int</span> v1, <span class="keywordtype">int</span> v2){</div><div class="line">    <span class="keywordflow">return</span> v1 &lt; v2;</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="keyword">auto</span> data = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(0, 8).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab6098a8e2412f51c87b01d098278a1e6">map</a>([](<span class="keywordtype">int</span> v){</div><div class="line">            std::stringstream s;</div><div class="line">            s &lt;&lt; <span class="stringliteral">&quot;Value &quot;</span> &lt;&lt; v;</div><div class="line">            <span class="keywordflow">return</span> std::make_pair(v % 3, s.str());</div><div class="line">        });</div><div class="line">    <span class="keyword">auto</span> values = data.<a class="code" href="classrxcpp_1_1observable.html#add577ed3ce82a45b2f69c0ff34c8a668">group_by</a>(</div><div class="line">            [](std::pair&lt;int, std::string&gt; v){<span class="keywordflow">return</span> v.first;},</div><div class="line">            [](std::pair&lt;int, std::string&gt; v){<span class="keywordflow">return</span> v.second;},</div><div class="line">            less);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<a class="code" href="classrxcpp_1_1grouped__observable.html">rxcpp::grouped_observable&lt;int, std::string&gt;</a> g){</div><div class="line">                <span class="keyword">auto</span> key = g.<a class="code" href="classrxcpp_1_1grouped__observable.html#a76c248311cdff169f01e067ed91a4e1d">get_key</a>();</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext: key = %d\n&quot;</span>, key);</div><div class="line">                g.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [key](<span class="keyword">const</span> std::string&amp; v){printf(<span class="stringliteral">&quot;[key %d] OnNext: %s\n&quot;</span>, key, v.c_str());},</div><div class="line">                    [key](){printf(<span class="stringliteral">&quot;[key %d] OnCompleted\n&quot;</span>, key);});</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: key = 0</div><div class="line">[key 0] OnNext: Value 0</div><div class="line">OnNext: key = 1</div><div class="line">[key 1] OnNext: Value 1</div><div class="line">OnNext: key = 2</div><div class="line">[key 2] OnNext: Value 2</div><div class="line">[key 0] OnNext: Value 3</div><div class="line">[key 1] OnNext: Value 4</div><div class="line">[key 2] OnNext: Value 5</div><div class="line">[key 0] OnNext: Value 6</div><div class="line">[key 1] OnNext: Value 7</div><div class="line">[key 2] OnNext: Value 8</div><div class="line">[key 0] OnCompleted</div><div class="line">[key 1] OnCompleted</div><div class="line">[key 2] OnCompleted</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(0, 8).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#add577ed3ce82a45b2f69c0ff34c8a668">group_by</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){<span class="keywordflow">return</span> v % 3;},</div><div class="line">            [](<span class="keywordtype">int</span> v){<span class="keywordflow">return</span> 10 * v;});</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<a class="code" href="classrxcpp_1_1grouped__observable.html">rxcpp::grouped_observable&lt;int, int&gt;</a> g){</div><div class="line">                <span class="keyword">auto</span> key = g.<a class="code" href="classrxcpp_1_1grouped__observable.html#a76c248311cdff169f01e067ed91a4e1d">get_key</a>();</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext: key = %d\n&quot;</span>, key);</div><div class="line">                g.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [key](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[key %d] OnNext: %d\n&quot;</span>, key, v);},</div><div class="line">                    [key](){printf(<span class="stringliteral">&quot;[key %d] OnCompleted\n&quot;</span>, key);});</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: key = 0</div><div class="line">[key 0] OnNext: 0</div><div class="line">OnNext: key = 1</div><div class="line">[key 1] OnNext: 10</div><div class="line">OnNext: key = 2</div><div class="line">[key 2] OnNext: 20</div><div class="line">[key 0] OnNext: 30</div><div class="line">[key 1] OnNext: 40</div><div class="line">[key 2] OnNext: 50</div><div class="line">[key 0] OnNext: 60</div><div class="line">[key 1] OnNext: 70</div><div class="line">[key 2] OnNext: 80</div><div class="line">[key 0] OnCompleted</div><div class="line">[key 1] OnCompleted</div><div class="line">[key 2] OnCompleted</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a1d29197dc2b5939507e719dd16820ede"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::ignore_elements </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do not emit any items from the source Observable, but allow termination notification (either onError or onCompleted) to pass through unchanged. </p>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits termination notification from the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 3, 4, 5).ignore_elements();</div><div class="line">    values.</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v) { printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a44ab13d5fdc2f350cd8065ac5152b431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::is_empty </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an Observable that emits true if the source Observable is empty, otherwise false. </p>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits a boolean value.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2, 3, 4, 5).is_empty();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">bool</span> v) { printf(<span class="stringliteral">&quot;OnNext: %s\n&quot;</span>, v ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>); },</div><div class="line">        []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="aa71e47ee8ea52772e576bffb94f58006"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::last </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable reduce it by sending only the last item. </p>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits only the very last item emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).last();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --> When the source observable calls on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;().<a class="code" href="classrxcpp_1_1observable.html#aa71e47ee8ea52772e576bffb94f58006">last</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1empty__error.html">rxcpp::empty_error</a>&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: <a class="code" href="classrxcpp_1_1observable.html#aa71e47ee8ea52772e576bffb94f58006">last</a>() requires a stream with at least one value</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ab6098a8e2412f51c87b01d098278a1e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::map </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use Selector to produce an item to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Selector</td><td>the type of the transforming function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the selector function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the items from the source observable, transformed by the specified function.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab6098a8e2412f51c87b01d098278a1e6">map</a>([](<span class="keywordtype">int</span> v){</div><div class="line">            <span class="keywordflow">return</span> 2 * v;</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 2</div><div class="line">OnNext: 4</div><div class="line">OnNext: 6</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="afcfa719cf263a2494b4cbe4b2662faee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::max </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable reduce it by taking the max value of the previous items. </p>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits a single item: the max of elements emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 4).max();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 4.000000</div><div class="line">OnCompleted</div></div><!-- fragment --> When the source observable completes without emitting any items: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;().<a class="code" href="classrxcpp_1_1observable.html#afcfa719cf263a2494b4cbe4b2662faee">max</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1empty__error.html">rxcpp::empty_error</a>&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: <a class="code" href="classrxcpp_1_1observable.html#afcfa719cf263a2494b4cbe4b2662faee">max</a>() requires a stream with at least one value</div></div><!-- fragment --> When the source observable calls on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 4).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html#afcfa719cf263a2494b4cbe4b2662faee">max</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a278b7eca33afc119ff6dc30bf70e7a78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each given observable subscribe. For each item emitted from all of the given observables, deliver from the new observable that is returned. </p>
<p>There are 2 variants of the operator:</p><ul>
<li>The source observable emits nested observables, nested observables are merged.</li>
<li>The source observable and the arguments v0...vn are used to provide the observables to merge.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional). </td></tr>
    <tr><td class="paramname">Value0</td><td>... (optional). </td></tr>
    <tr><td class="paramname">ValueN</td><td>types of source observables (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>the scheduler to synchronize sources from different contexts (optional). </td></tr>
    <tr><td class="paramname">v0</td><td>... (optional). </td></tr>
    <tr><td class="paramname">vn</td><td>source observables (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits items that are the result of flattening the observables emitted by the source observable.</dd></dl>
<p>If scheduler is omitted, identity_current_thread is used.</p>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer1 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(20)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer2 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(30)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer3 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 3;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> base = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(o1.as_dynamic(), o2, o3);</div><div class="line">    <span class="keyword">auto</span> values = base.merge(<a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481303181056] Timer1 fired</div><div class="line">[thread 47481303181056] OnNext: 1</div><div class="line">[thread 47481303181056] Timer2 fired</div><div class="line">[thread 47481303181056] OnNext: 2</div><div class="line">[thread 47481303181056] Timer3 fired</div><div class="line">[thread 47481303181056] OnNext: 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(15)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 1;});</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 2;});</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(5)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 3;});</div><div class="line">    <span class="keyword">auto</span> base = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(o1.as_dynamic(), o2, o3);</div><div class="line">    <span class="keyword">auto</span> values = base.<a class="code" href="classrxcpp_1_1observable.html#a278b7eca33afc119ff6dc30bf70e7a78">merge</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 3</div><div class="line">OnNext: 2</div><div class="line">OnNext: 1</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(15)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 1;});</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 2;});</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(5)).map([](<span class="keywordtype">int</span>) {<span class="keywordflow">return</span> 3;});</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#a278b7eca33afc119ff6dc30bf70e7a78">merge</a>(o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 3</div><div class="line">OnNext: 2</div><div class="line">OnNext: 1</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(10)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer1 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(20)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer2 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(30)).map([](<span class="keywordtype">int</span>) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Timer3 fired\n&quot;</span>, get_pid().c_str());</div><div class="line">        <span class="keywordflow">return</span> 3;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> values = o1.<a class="code" href="classrxcpp_1_1observable.html#a278b7eca33afc119ff6dc30bf70e7a78">merge</a>(<a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>(), o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481303181056] Timer1 fired</div><div class="line">[thread 47481303181056] OnNext: 1</div><div class="line">[thread 47481303181056] Timer2 fired</div><div class="line">[thread 47481303181056] OnNext: 2</div><div class="line">[thread 47481303181056] Timer3 fired</div><div class="line">[thread 47481303181056] OnNext: 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="afc307f7e12e46db1b6a1d95b7bdf3777"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::merge_transform </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use the CollectionSelector to produce an observable and subscribe to that observable. For each item from all of the produced observables use the ResultSelector to produce a value to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CollectionSelector</td><td>the type of the observable producing function. CollectionSelector must be a function with the signature observable(flat_map::source_value_type) </td></tr>
    <tr><td class="paramname">ResultSelector</td><td>the type of the aggregation function (optional). ResultSelector must be a function with the signature flat_map::value_type(flat_map::source_value_type, flat_map::collection_value_type). </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a function that returns an observable for each item emitted by the source observable. </td></tr>
    <tr><td class="paramname">rs</td><td>a function that combines one item emitted by each of the source and collection observables and returns an item to be emitted by the resulting observable (optional). </td></tr>
    <tr><td class="paramname">cn</td><td>the scheduler to synchronize sources from different contexts (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the results of applying a function to a pair of values emitted by the source observable and the collection observable.</dd></dl>
<p>Observables, produced by the CollectionSelector, are merged. There is another operator <a class="el" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee" title="For each item from this observable use the CollectionSelector to produce an observable and subscribe ...">rxcpp::observable&lt;T,SourceType&gt;::flat_map</a> that works similar but concatenates the observables.</p>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee">flat_map</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){</div><div class="line">                <span class="keywordflow">return</span></div><div class="line">                    <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(10 * v), std::chrono::milliseconds(50)).</div><div class="line">                    <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3);</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> v_main, <span class="keywordtype">long</span> v_sub){</div><div class="line">                <span class="keywordflow">return</span> std::make_tuple(v_main, v_sub);</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, long&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d - %ld\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 - 1</div><div class="line">OnNext: 2 - 1</div><div class="line">OnNext: 3 - 1</div><div class="line">OnNext: 1 - 2</div><div class="line">OnNext: 2 - 2</div><div class="line">OnNext: 3 - 2</div><div class="line">OnNext: 1 - 3</div><div class="line">OnNext: 2 - 3</div><div class="line">OnNext: 3 - 3</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab1195b083ffa5a97fb1deb854c1e9bee">flat_map</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] Call CollectionSelector(v = %d)\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">                <span class="keywordflow">return</span></div><div class="line">                    <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(10 * v), std::chrono::milliseconds(50)).</div><div class="line">                    <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3);</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> v_main, <span class="keywordtype">int</span> v_sub){</div><div class="line">                printf(<span class="stringliteral">&quot;[thread %s] Call ResultSelector(v_main = %d, v_sub = %d)\n&quot;</span>, get_pid().c_str(), v_main, v_sub);</div><div class="line">                <span class="keywordflow">return</span> std::make_tuple(v_main, v_sub);</div><div class="line">            },</div><div class="line">            <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, long&gt; v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d - %ld\n&quot;</span>, get_pid().c_str(), std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 1)</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 2)</div><div class="line">[thread 47481303181056] Call CollectionSelector(v = 3)</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 1 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 2 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 1)</div><div class="line">[thread 47481303181056] OnNext: 3 - 1</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 1 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 2 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 2)</div><div class="line">[thread 47481303181056] OnNext: 3 - 2</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 1, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 1 - 3</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 2, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 2 - 3</div><div class="line">[thread 47481303181056] Call ResultSelector(v_main = 3, v_sub = 3)</div><div class="line">[thread 47481303181056] OnNext: 3 - 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a07a1bbeca10e00e1ae152fb73141021c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::min </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable reduce it by taking the min value of the previous items. </p>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits a single item: the min of elements emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 4).min();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1.000000</div><div class="line">OnCompleted</div></div><!-- fragment --> When the source observable completes without emitting any items: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;().<a class="code" href="classrxcpp_1_1observable.html#a07a1bbeca10e00e1ae152fb73141021c">min</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1empty__error.html">rxcpp::empty_error</a>&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: <a class="code" href="classrxcpp_1_1observable.html#a07a1bbeca10e00e1ae152fb73141021c">min</a>() requires a stream with at least one value</div></div><!-- fragment --> When the source observable calls on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 4).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html#a07a1bbeca10e00e1ae152fb73141021c">min</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a7312ee6b988b30c82cca3a5e68855ea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::multicast </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="abbe2255f4f5b3517d615583ae7085148"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::observe_on </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All values are queued and delivered using the scheduler from the supplied coordination. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>the scheduler to notify observers on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The source observable modified so that its observers are notified on the specified scheduler.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab6098a8e2412f51c87b01d098278a1e6">map</a>([](<span class="keywordtype">int</span> v){</div><div class="line">            printf(<span class="stringliteral">&quot;[thread %s] Emit value %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">            <span class="keywordflow">return</span> v;</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#abbe2255f4f5b3517d615583ae7085148">observe_on</a>(<a class="code" href="namespacerxcpp.html#ae8b33e61973289899b1cbe1d6a32361d">rxcpp::synchronize_new_thread</a>()).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Emit value 1</div><div class="line">[thread 47481267428736] Emit value 2</div><div class="line">[thread 47481267428736] Emit value 3</div><div class="line">[thread 47481303181056] OnNext: 1</div><div class="line">[thread 47481303181056] OnNext: 2</div><div class="line">[thread 47481303181056] OnNext: 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> Invoking <a class="el" href="classrxcpp_1_1observable.html#a225ad69622b7c80328bae63232de84b6" title="Subscription and unsubscription are queued and delivered using the scheduler from the supplied coordi...">rxcpp::observable::subscribe_on</a> operator, instead of observe_on, gives following results: <div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481313687296] Emit value 1</div><div class="line">[thread 47481313687296] OnNext: 1</div><div class="line">[thread 47481313687296] Emit value 2</div><div class="line">[thread 47481313687296] OnNext: 2</div><div class="line">[thread 47481313687296] Emit value 3</div><div class="line">[thread 47481313687296] OnNext: 3</div><div class="line">[thread 47481313687296] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a55183eba74706e04b912f592d677f1d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::on_error_resume_next </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If an error occurs, take the result from the Selector and subscribe to that instead. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Selector</td><td>the actual type of a function of the form <code>observable&lt;T&gt;(std::exception_ptr)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the function of the form <code>observable&lt;T&gt;(std::exception_ptr)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the items from the source observable and switches to a new observable on error.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a55183eba74706e04b912f592d677f1d8">on_error_resume_next</a>([](std::exception_ptr ep){</div><div class="line">            printf(<span class="stringliteral">&quot;Resuming after: %s\n&quot;</span>, <a class="code" href="namespacerxcpp_1_1util.html#a393c2767bfe9fb7a35297ecb307a7896">rxu::what</a>(ep).c_str());</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="namespacerxcpp_1_1sources.html#a801daa2d18ecb5fb28be86732a40e57a">rxcpp::observable&lt;&gt;::just</a>(-1);</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, <a class="code" href="namespacerxcpp_1_1util.html#a393c2767bfe9fb7a35297ecb307a7896">rxu::what</a>(ep).c_str());</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">Resuming after: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div><div class="line">OnNext: -1</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a28636f8a78edee595b623560f828c88b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::pairwise </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take values pairwise from this observable. </p>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits tuples of two the most recent items emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 5).pairwise();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, int&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d, %d\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1, 2</div><div class="line">OnNext: 2, 3</div><div class="line">OnNext: 3, 4</div><div class="line">OnNext: 4, 5</div><div class="line">OnCompleted</div></div><!-- fragment --> If the source observable emits less than two items, no pairs are emitted by the source observable: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a801daa2d18ecb5fb28be86732a40e57a">rxcpp::observable&lt;&gt;::just</a>(1).pairwise();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, int&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d, %d\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a11cda439be2f5fe2c14d828fab60c894"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::publish </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn a cold observable hot and allow connections to the source to be independent of subscriptions. Turn a cold observable hot, send the most recent value to any new subscriber, and allow connections to the source to be independent of subscriptions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the emitted item (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>an initial item to be emitted by the resulting observable at connection time before emitting the items from the source observable; not emitted to observers that subscribe after the time of connection (optional). </td></tr>
    <tr><td class="paramname">cs</td><td>the subscription to control lifetime (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classrxcpp_1_1connectable__observable.html" title="a source of values that is shared across all subscribers and does not start until connectable_observa...">rxcpp::connectable_observable</a> that upon connection causes the source observable to emit items to its observers.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50), <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>()).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a11cda439be2f5fe2c14d828fab60c894">publish</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[1] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[1] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Another subscription from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[2] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[2] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    values.connect();</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(75)).subscribe([&amp;](<span class="keywordtype">long</span>){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[3] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[3] OnCompleted\n&quot;</span>);});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Add blocking subscription to see results</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe();</div></div><!-- fragment --><div class="fragment"><div class="line">[1] OnNext: 1</div><div class="line">[2] OnNext: 1</div><div class="line">[1] OnNext: 2</div><div class="line">[2] OnNext: 2</div><div class="line">[1] OnNext: 3</div><div class="line">[2] OnNext: 3</div><div class="line">[3] OnNext: 3</div><div class="line">[1] OnNext: 4</div><div class="line">[2] OnNext: 4</div><div class="line">[3] OnNext: 4</div><div class="line">[1] OnNext: 5</div><div class="line">[2] OnNext: 5</div><div class="line">[3] OnNext: 5</div><div class="line">[1] OnCompleted</div><div class="line">[2] OnCompleted</div><div class="line">[3] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50), <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>()).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a11cda439be2f5fe2c14d828fab60c894">publish</a>(0L);</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[1] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[1] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Another subscription from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[2] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[2] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    values.connect();</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(75)).subscribe([&amp;](<span class="keywordtype">long</span>){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[3] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[3] OnCompleted\n&quot;</span>);});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Add blocking subscription to see results</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe();</div></div><!-- fragment --><div class="fragment"><div class="line">[1] OnNext: 0</div><div class="line">[2] OnNext: 0</div><div class="line">[1] OnNext: 1</div><div class="line">[2] OnNext: 1</div><div class="line">[1] OnNext: 2</div><div class="line">[2] OnNext: 2</div><div class="line">[3] OnNext: 2</div><div class="line">[1] OnNext: 3</div><div class="line">[2] OnNext: 3</div><div class="line">[3] OnNext: 3</div><div class="line">[1] OnNext: 4</div><div class="line">[2] OnNext: 4</div><div class="line">[3] OnNext: 4</div><div class="line">[1] OnNext: 5</div><div class="line">[2] OnNext: 5</div><div class="line">[3] OnNext: 5</div><div class="line">[1] OnCompleted</div><div class="line">[2] OnCompleted</div><div class="line">[3] OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a2df5bfc80004d2e46360a75aa9e418b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::publish_synchronized </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn a cold observable hot and allow connections to the source to be independent of subscriptions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>a scheduler all values are queued and delivered on. </td></tr>
    <tr><td class="paramname">cs</td><td>the subscription to control lifetime (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classrxcpp_1_1connectable__observable.html" title="a source of values that is shared across all subscribers and does not start until connectable_observa...">rxcpp::connectable_observable</a> that upon connection causes the source observable to emit items to its observers, on the specified scheduler.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a2df5bfc80004d2e46360a75aa9e418b8">publish_synchronized</a>(<a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[1] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[1] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Another subscription from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[2] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[2] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    values.connect();</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(75)).subscribe([&amp;](<span class="keywordtype">long</span>){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[3] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[3] OnCompleted\n&quot;</span>);});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Add blocking subscription to see results</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe();</div></div><!-- fragment --><div class="fragment"><div class="line">[1] OnNext: 1</div><div class="line">[2] OnNext: 1</div><div class="line">[1] OnNext: 2</div><div class="line">[2] OnNext: 2</div><div class="line">[1] OnNext: 3</div><div class="line">[2] OnNext: 3</div><div class="line">[1] OnNext: 4</div><div class="line">[2] OnNext: 4</div><div class="line">[1] OnNext: 5</div><div class="line">[2] OnNext: 5</div><div class="line">[1] OnCompleted</div><div class="line">[2] OnCompleted</div><div class="line">[3] OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a8cb7300bc8a57cfbd3b5c8033102a983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use Accumulator to combine items, when completed use ResultSelector to produce a value that will be emitted from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Seed</td><td>the type of the initial value for the accumulator </td></tr>
    <tr><td class="paramname">Accumulator</td><td>the type of the data accumulating function </td></tr>
    <tr><td class="paramname">ResultSelector</td><td>the type of the result producing function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the initial value for the accumulator </td></tr>
    <tr><td class="paramname">a</td><td>an accumulator function to be invoked on each item emitted by the source observable, the result of which will be used in the next accumulator call </td></tr>
    <tr><td class="paramname">rs</td><td>a result producing function that makes the final value from the last accumulator call result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits a single item that is the result of accumulating the output from the items emitted by the source observable.</dd></dl>
<p>Some basic reduce-type operators have already been implemented:</p><ul>
<li><a class="el" href="namespacerxcpp_1_1operators.html#ac19a7a29ca5be51edbcd7c7d4482e048" title="For each item from this observable reduce it by sending only the first item. ">rxcpp::operators::first</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a84e276fcb6e305b3139b4c8cb9edb3ac" title="For each item from this observable reduce it by sending only the last item. ">rxcpp::operators::last</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a0f074d4712deb435a74ab5890a8108fa" title="For each item from this observable reduce it by incrementing a count. ">rxcpp::operators::count</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#ae58d3cf6a72f64a261918a745a64beb6" title="For each item from this observable reduce it by adding to the previous items. ">rxcpp::operators::sum</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a2798e0ee0ee6b53efae26b60f1d18f4c" title="For each item from this observable reduce it by adding to the previous values and then dividing by th...">rxcpp::operators::average</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a419caaea34eea86b9951205a32b26348" title="For each item from this observable reduce it by taking the min value of the previous items...">rxcpp::operators::min</a></li>
<li><a class="el" href="namespacerxcpp_1_1operators.html#a574e80abbc68529816f47cb0bcaa97d6" title="For each item from this observable reduce it by taking the max value of the previous items...">rxcpp::operators::max</a></li>
</ul>
<dl class="section user"><dt>Sample Code</dt><dd>Geometric mean of source values: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a>(</div><div class="line">            std::make_pair(0, 1.0),</div><div class="line">            [](std::pair&lt;int, double&gt; seed, <span class="keywordtype">int</span> v){</div><div class="line">                seed.first += 1;</div><div class="line">                seed.second *= v;</div><div class="line">                <span class="keywordflow">return</span> seed;</div><div class="line">            },</div><div class="line">            [](std::pair&lt;int, double&gt; res){</div><div class="line">                <span class="keywordflow">return</span> std::pow(res.second, 1.0 / res.first);</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">double</span> v){printf(<span class="stringliteral">&quot;OnNext: %lf\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 3.380015</div><div class="line">OnCompleted</div></div><!-- fragment --> If the source observable completes without emitting any items, the resulting observable emits the result of passing the initial seed to the result selector: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a>(</div><div class="line">            1,</div><div class="line">            [](<span class="keywordtype">int</span>,<span class="keywordtype">int</span>){<span class="keywordflow">return</span> 0;},</div><div class="line">            [](<span class="keywordtype">int</span> res){<span class="keywordflow">return</span> res;});</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnCompleted</div></div><!-- fragment --> If the accumulator raises an exception, it is returned by the resulting observable in on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a>(</div><div class="line">            0,</div><div class="line">            [](<span class="keywordtype">int</span> seed, <span class="keywordtype">int</span> v){</div><div class="line">                <span class="keywordflow">if</span> (v == 2)</div><div class="line">                    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Exception from accumulator&quot;</span>);</div><div class="line">                <span class="keywordflow">return</span> seed;</div><div class="line">            },</div><div class="line">            [](<span class="keywordtype">int</span> res){<span class="keywordflow">return</span> res;});</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Exception <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> accumulator</div></div><!-- fragment --> The same for exceptions raised by the result selector: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a8cb7300bc8a57cfbd3b5c8033102a983">reduce</a>(</div><div class="line">            0,</div><div class="line">            [](<span class="keywordtype">int</span> seed, <span class="keywordtype">int</span> v){<span class="keywordflow">return</span> seed + v;},</div><div class="line">            [](<span class="keywordtype">int</span> res){</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Exception from result selector&quot;</span>);</div><div class="line">                <span class="keywordflow">return</span> res;</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Exception <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> result selector</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="af189a03bfcd06ab654a6ec8bb4941474"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::repeat </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeat this observable for the given number of times or infinitely. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Count</td><td>the type of the counter (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The number of times the source observable items are repeated (optional). If not specified, infinitely repeats the source observable. Specifying 0 returns an empty sequence immediately</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that repeats the sequence of items emitted by the source observable for t times.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2).repeat(3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnCompleted</div></div><!-- fragment --> If the source observable calls on_error, repeat stops: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#af189a03bfcd06ab654a6ec8bb4941474">repeat</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="afbb26338385e6fa3d3a3cce2df32e948"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::replay </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1) replay(optional Coordination, optional CompositeSubscription) Turn a cold observable hot, send all earlier emitted values to any new subscriber, and allow connections to the source to be independent of subscriptions. </p>
<p>2) replay(Count, optional Coordination, optional CompositeSubscription) Turn a cold observable hot, send at most count of earlier emitted values to any new subscriber, and allow connections to the source to be independent of subscriptions.</p>
<p>3) replay(Duration, optional Coordination, optional CompositeSubscription) Turn a cold observable hot, send values emitted within a specified time window to any new subscriber, and allow connections to the source to be independent of subscriptions.</p>
<p>4) replay(Count, Duration, optional Coordination, optional CompositeSubscription) Turn a cold observable hot, send at most count of values emitted within a specified time window to any new subscriber, and allow connections to the source to be independent of subscriptions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of the time interval (optional). </td></tr>
    <tr><td class="paramname">Count</td><td>the type of the maximum number of the most recent items sent to new observers (optional). </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the maximum number of the most recent items sent to new observers (optional). </td></tr>
    <tr><td class="paramname">d</td><td>the duration of the window in which the replayed items must be emitted </td></tr>
    <tr><td class="paramname">cn</td><td>a scheduler all values are queued and delivered on (optional). </td></tr>
    <tr><td class="paramname">cs</td><td>the subscription to control lifetime (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classrxcpp_1_1connectable__observable.html" title="a source of values that is shared across all subscribers and does not start until connectable_observa...">rxcpp::connectable_observable</a> that shares a single subscription to the underlying observable that will replay all of its items and notifications to any future observer.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50), <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>()).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[1] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[1] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    values.connect();</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(125)).subscribe([&amp;](<span class="keywordtype">long</span>){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[2] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[2] OnCompleted\n&quot;</span>);});</div><div class="line">    });</div></div><!-- fragment --><div class="fragment"><div class="line">[1] OnNext: 1</div><div class="line">[1] OnNext: 2</div><div class="line">[1] OnNext: 3</div><div class="line">[2] OnNext: 1</div><div class="line">[2] OnNext: 2</div><div class="line">[2] OnNext: 3</div><div class="line">[1] OnNext: 4</div><div class="line">[2] OnNext: 4</div><div class="line">[1] OnNext: 5</div><div class="line">[2] OnNext: 5</div><div class="line">[1] OnCompleted</div><div class="line">[2] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> coordination = <a class="code" href="namespacerxcpp.html#a4c76fbc521e079b49840704f65c7f39f">rxcpp::serialize_new_thread</a>();</div><div class="line">    <span class="keyword">auto</span> worker = coordination.create_coordinator().get_worker();</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a>(coordination);</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    worker.schedule([&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s][1] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s][1] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    worker.schedule(coordination.now() + std::chrono::milliseconds(125), [&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s][2] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s][2] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    worker.schedule([&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.connect();</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Add blocking subscription to see results</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe();</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481303181056][1] OnNext: 1</div><div class="line">[thread 47481303181056][1] OnNext: 2</div><div class="line">[thread 47481303181056][1] OnNext: 3</div><div class="line">[thread 47481303181056][2] OnNext: 1</div><div class="line">[thread 47481303181056][2] OnNext: 2</div><div class="line">[thread 47481303181056][2] OnNext: 3</div><div class="line">[thread 47481303181056][1] OnNext: 4</div><div class="line">[thread 47481303181056][2] OnNext: 4</div><div class="line">[thread 47481303181056][1] OnNext: 5</div><div class="line">[thread 47481303181056][2] OnNext: 5</div><div class="line">[thread 47481303181056][1] OnCompleted</div><div class="line">[thread 47481303181056][2] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50), <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>()).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a>(2);</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[1] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[1] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    values.connect();</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(125)).subscribe([&amp;](<span class="keywordtype">long</span>){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[2] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[2] OnCompleted\n&quot;</span>);});</div><div class="line">    });</div></div><!-- fragment --><div class="fragment"><div class="line">[1] OnNext: 1</div><div class="line">[1] OnNext: 2</div><div class="line">[1] OnNext: 3</div><div class="line">[2] OnNext: 2</div><div class="line">[2] OnNext: 3</div><div class="line">[1] OnNext: 4</div><div class="line">[2] OnNext: 4</div><div class="line">[1] OnNext: 5</div><div class="line">[2] OnNext: 5</div><div class="line">[1] OnCompleted</div><div class="line">[2] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> coordination = <a class="code" href="namespacerxcpp.html#a4c76fbc521e079b49840704f65c7f39f">rxcpp::serialize_new_thread</a>();</div><div class="line">    <span class="keyword">auto</span> worker = coordination.create_coordinator().get_worker();</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a>(2, coordination);</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    worker.schedule([&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s][1] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s][1] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    worker.schedule(coordination.now() + std::chrono::milliseconds(125), [&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s][2] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s][2] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    worker.schedule([&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.connect();</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Add blocking subscription to see results</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe();</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481305282304][1] OnNext: 1</div><div class="line">[thread 47481305282304][1] OnNext: 2</div><div class="line">[thread 47481305282304][1] OnNext: 3</div><div class="line">[thread 47481305282304][2] OnNext: 2</div><div class="line">[thread 47481305282304][2] OnNext: 3</div><div class="line">[thread 47481305282304][1] OnNext: 4</div><div class="line">[thread 47481305282304][2] OnNext: 4</div><div class="line">[thread 47481305282304][1] OnNext: 5</div><div class="line">[thread 47481305282304][2] OnNext: 5</div><div class="line">[thread 47481305282304][1] OnCompleted</div><div class="line">[thread 47481305282304][2] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50), <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>()).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a>(std::chrono::milliseconds(125));</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[1] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[1] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    values.connect();</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(175)).subscribe([&amp;](<span class="keywordtype">long</span>){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[2] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[2] OnCompleted\n&quot;</span>);});</div><div class="line">    });</div></div><!-- fragment --><div class="fragment"><div class="line">[1] OnNext: 1</div><div class="line">[1] OnNext: 2</div><div class="line">[1] OnNext: 3</div><div class="line">[1] OnNext: 4</div><div class="line">[2] OnNext: 2</div><div class="line">[2] OnNext: 3</div><div class="line">[2] OnNext: 4</div><div class="line">[1] OnNext: 5</div><div class="line">[2] OnNext: 5</div><div class="line">[1] OnCompleted</div><div class="line">[2] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> coordination = <a class="code" href="namespacerxcpp.html#a4c76fbc521e079b49840704f65c7f39f">rxcpp::serialize_new_thread</a>();</div><div class="line">    <span class="keyword">auto</span> worker = coordination.create_coordinator().get_worker();</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a>(std::chrono::milliseconds(125), coordination);</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    worker.schedule([&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s][1] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s][1] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    worker.schedule(coordination.now() + std::chrono::milliseconds(175), [&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s][2] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s][2] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    worker.schedule([&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.connect();</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Add blocking subscription to see results</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe();</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481307383552][1] OnNext: 1</div><div class="line">[thread 47481307383552][1] OnNext: 2</div><div class="line">[thread 47481307383552][1] OnNext: 3</div><div class="line">[thread 47481307383552][1] OnNext: 4</div><div class="line">[thread 47481307383552][2] OnNext: 2</div><div class="line">[thread 47481307383552][2] OnNext: 3</div><div class="line">[thread 47481307383552][2] OnNext: 4</div><div class="line">[thread 47481307383552][1] OnNext: 5</div><div class="line">[thread 47481307383552][2] OnNext: 5</div><div class="line">[thread 47481307383552][1] OnCompleted</div><div class="line">[thread 47481307383552][2] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50), <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>()).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a>(2, std::chrono::milliseconds(125));</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">        [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[1] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;[1] OnCompleted\n&quot;</span>);});</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    values.connect();</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(175)).subscribe([&amp;](<span class="keywordtype">long</span>){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[2] OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[2] OnCompleted\n&quot;</span>);});</div><div class="line">    });</div></div><!-- fragment --><div class="fragment"><div class="line">[1] OnNext: 1</div><div class="line">[1] OnNext: 2</div><div class="line">[1] OnNext: 3</div><div class="line">[1] OnNext: 4</div><div class="line">[2] OnNext: 3</div><div class="line">[2] OnNext: 4</div><div class="line">[1] OnNext: 5</div><div class="line">[2] OnNext: 5</div><div class="line">[1] OnCompleted</div><div class="line">[2] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> coordination = <a class="code" href="namespacerxcpp.html#a4c76fbc521e079b49840704f65c7f39f">rxcpp::serialize_new_thread</a>();</div><div class="line">    <span class="keyword">auto</span> worker = coordination.create_coordinator().get_worker();</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(50)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#afbb26338385e6fa3d3a3cce2df32e948">replay</a>(2, std::chrono::milliseconds(125), coordination);</div><div class="line"></div><div class="line">    <span class="comment">// Subscribe from the beginning</span></div><div class="line">    worker.schedule([&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s][1] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s][1] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Wait before subscribing</span></div><div class="line">    worker.schedule(coordination.now() + std::chrono::milliseconds(175), [&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s][2] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s][2] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Start emitting</span></div><div class="line">    worker.schedule([&amp;](<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1schedulers_1_1schedulable.html">rxcpp::schedulers::schedulable</a>&amp;){</div><div class="line">        values.connect();</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="comment">// Add blocking subscription to see results</span></div><div class="line">    values.<a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().subscribe();</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481309484800][1] OnNext: 1</div><div class="line">[thread 47481309484800][1] OnNext: 2</div><div class="line">[thread 47481309484800][1] OnNext: 3</div><div class="line">[thread 47481309484800][1] OnNext: 4</div><div class="line">[thread 47481309484800][2] OnNext: 3</div><div class="line">[thread 47481309484800][2] OnNext: 4</div><div class="line">[thread 47481309484800][1] OnNext: 5</div><div class="line">[thread 47481309484800][2] OnNext: 5</div><div class="line">[thread 47481309484800][1] OnCompleted</div><div class="line">[thread 47481309484800][2] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a68c3de11d01b74bf73553cc932688136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::retry </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retry this observable for the given number of times. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Count</td><td>the type of the counter (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the total number of tries (optional), i.e. retry(2) means one normal try, before an error occurs, and one retry. If not specified, infinitely retries the source observable. Specifying 0 returns immediately without subscribing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that mirrors the source observable, resubscribing to it if it calls on_error up to a specified number of retries.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> source = <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">rxcpp::observable&lt;&gt;::from</a>(1, 2).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>)));</div><div class="line">    <span class="keyword">auto</span> values = source.<a class="code" href="classrxcpp_1_1observable.html#a68c3de11d01b74bf73553cc932688136">retry</a>(3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a4f2fc988b96239a31ed85d8161a031e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::sample_with_time </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an Observable that emits the most recent items emitted by the source Observable within periodic time intervals. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of time interval. </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the period of time to sample the source observable. </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler for the items (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the most recently emitted item since the previous sampling.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a4f2fc988b96239a31ed85d8161a031e4">sample_with_time</a>(std::chrono::milliseconds(4));</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v) {</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext: %ld\n&quot;</span>, v);</div><div class="line">            },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 3</div><div class="line">OnNext: 5</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a62939b867fda18e9d04dd7267bc67ac7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::scan </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use Accumulator to combine items into a value that will be emitted from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Seed</td><td>the type of the initial value for the accumulator. </td></tr>
    <tr><td class="paramname">Accumulator</td><td>the type of the data accumulating function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>the initial value for the accumulator. </td></tr>
    <tr><td class="paramname">a</td><td>an accumulator function to be invoked on each item emitted by the source observable, whose result will be emitted and used in the next accumulator call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits the results of each call to the accumulator function.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a62939b867fda18e9d04dd7267bc67ac7">scan</a>(</div><div class="line">            0,</div><div class="line">            [](<span class="keywordtype">int</span> seed, <span class="keywordtype">int</span> v){</div><div class="line">                <span class="keywordflow">return</span> seed + v;</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 3</div><div class="line">OnNext: 6</div><div class="line">OnNext: 10</div><div class="line">OnNext: 15</div><div class="line">OnNext: 21</div><div class="line">OnNext: 28</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="aac85bbfc4fa1aa7ca30564a96822eca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::sequence_equal </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether two Observables emit the same sequence of items. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherSource</td><td>the type of the other observable. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>the type of the value comparing function (optional). The signature should be equivalent to the following: bool pred(const T1&amp; a, const T2&amp; b); </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the other Observable that emits items to compare. </td></tr>
    <tr><td class="paramname">pred</td><td>the function that implements comparison of two values (optional). </td></tr>
    <tr><td class="paramname">cn</td><td>the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits true only if both sequences terminate normally after emitting the same sequence of items in the same order; otherwise it will emit false.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> source = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    <span class="keyword">auto</span> values = source.<a class="code" href="classrxcpp_1_1observable.html#aac85bbfc4fa1aa7ca30564a96822eca7">sequence_equal</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::range</a>(1, 3));</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">bool</span> v){ printf(<span class="stringliteral">&quot;OnNext: %s\n&quot;</span>, v ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>); },</div><div class="line">            [](){ printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);} );</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: <span class="keyword">true</span></div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a5283adf7187df741a8a22d7bd73d270a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make new observable with skipped first count items from this observable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Count</td><td>the type of the items counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the number of items to skip</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that is identical to the source observable except that it does not emit the first t items that the source observable emits.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).skip(3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnNext: 6</div><div class="line">OnNext: 7</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="aa8a0c932a49d082c0280a2c4a332d423"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::skip_last </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make new observable with skipped last count items from this observable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Count</td><td>the type of the items counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the number of last items to skip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that is identical to the source observable except that it does not emit the last t items that the source observable emits.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).skip_last(3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a6faa14f5212a960591df205ea76a7b37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::skip_until </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make new observable with items skipped until on_next occurs on the trigger observable or until the specified time. skip_until takes (TriggerObservable, optional Coordination) or (TimePoint, optional Coordination) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriggerSource</td><td>the type of the trigger observable. </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>an observable that has to emit an item before the source observable's elements begin to be mirrored by the resulting observable. </td></tr>
    <tr><td class="paramname">cn</td><td>the scheduler to use for scheduling the items (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that skips items from the source observable until the second observable emits an item or the time runs out, then emits the remaining items.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> source = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(10)).take(7);</div><div class="line">    <span class="keyword">auto</span> trigger = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(25));</div><div class="line">    <span class="keyword">auto</span> values = source.<a class="code" href="classrxcpp_1_1observable.html#a6faa14f5212a960591df205ea76a7b37">skip_until</a>(trigger);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnNext: 6</div><div class="line">OnNext: 7</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> source = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(10)).take(7).map([](<span class="keywordtype">long</span> v){</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source emits, value = %ld\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> trigger = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(25)).map([](<span class="keywordtype">long</span> v){</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Trigger emits, value = %ld\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> values = source.<a class="code" href="classrxcpp_1_1observable.html#a6faa14f5212a960591df205ea76a7b37">skip_until</a>(trigger, <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Source emits, value = 1</div><div class="line">[thread 47481267428736] Source emits, value = 2</div><div class="line">[thread 47481267428736] Source emits, value = 3</div><div class="line">[thread 47481267428736] Trigger emits, value = 1</div><div class="line">[thread 47481267428736] Source emits, value = 4</div><div class="line">[thread 47481311586048] OnNext: 4</div><div class="line">[thread 47481267428736] Source emits, value = 5</div><div class="line">[thread 47481311586048] OnNext: 5</div><div class="line">[thread 47481267428736] Source emits, value = 6</div><div class="line">[thread 47481311586048] OnNext: 6</div><div class="line">[thread 47481267428736] Source emits, value = 7</div><div class="line">[thread 47481311586048] OnNext: 7</div><div class="line">[thread 47481311586048] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a84801c399e8407d904efb3e51206adb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::start_with </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start with the supplied values, then concatenate this observable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value0</td><td>... </td></tr>
    <tr><td class="paramname">ValueN</td><td>the type of sending values</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v0</td><td>... </td></tr>
    <tr><td class="paramname">vn</td><td>values to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the specified items and then emits the items emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(10, 12).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a84801c399e8407d904efb3e51206adb3">start_with</a>(1, 2, 3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 10</div><div class="line">OnNext: 11</div><div class="line">OnNext: 12</div><div class="line">OnCompleted</div></div><!-- fragment --> Another form of this operator, <a class="el" href="classrxcpp_1_1observable_3_01void_00_01void_01_4.html#add8d928bfec0ef68e3ce757ee8c288b3">rxcpp::observable&lt;void, void&gt;::start_with</a>, gets the source observable as a parameter: <div class="fragment"><div class="line">    <span class="keyword">auto</span> <a class="code" href="classrxcpp_1_1observable.html#a154ab5e07d035fffd5c07dc69361ca55">observable</a> = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(10, 12);</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html#a84801c399e8407d904efb3e51206adb3">rxcpp::observable&lt;&gt;::start_with</a>(<a class="code" href="classrxcpp_1_1observable.html#a154ab5e07d035fffd5c07dc69361ca55">observable</a>, 1, 2, 3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 10</div><div class="line">OnNext: 11</div><div class="line">OnNext: 12</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="aee091cb373e1c0d392b2b2d208cedfda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... ArgN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::subscribe </td>
          <td>(</td>
          <td class="paramtype">ArgN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classrxcpp_1_1composite__subscription.html">composite_subscription</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribe will cause the source observable to emit values to the provided subscriber. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArgN</td><td>types of the subscriber parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">an</td><td>the parameters for making a subscriber</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A subscription with which the observer can stop receiving items before the observable has finished sending them.</dd></dl>
<p>The arguments of subscribe are forwarded to <a class="el" href="namespacerxcpp.html#a242192794ecb4d2fdb69783c5c9fd24f">rxcpp::make_subscriber</a> function. Some possible alternatives are:</p>
<ul>
<li>Pass an already composed <a class="el" href="classrxcpp_1_1subscriber.html" title="binds an observer that consumes values with a composite_subscription that controls lifetime...">rxcpp::subscriber</a>: <div class="fragment"><div class="line">    <span class="keyword">auto</span> subscriber = rxcpp::make_subscriber&lt;int&gt;(</div><div class="line">        [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    values.subscribe(subscriber);</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --></li>
<li>Pass an <a class="el" href="classrxcpp_1_1observer.html" title="consumes values from an observable using State that may implement on_next, on_error and on_completed ...">rxcpp::observer</a>. This allows subscribing the same subscriber to several observables: <div class="fragment"><div class="line">    <span class="keyword">auto</span> subscriber = rxcpp::make_subscriber&lt;int&gt;(</div><div class="line">        [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div><div class="line">    <span class="keyword">auto</span> values1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    <span class="keyword">auto</span> values2 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(4, 6);</div><div class="line">    values1.subscribe(subscriber.get_observer());</div><div class="line">    values2.subscribe(subscriber.get_observer());</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnCompleted</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnNext: 6</div><div class="line">OnCompleted</div></div><!-- fragment --></li>
<li>Pass an <code>on_next</code> handler: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    values.subscribe(</div><div class="line">        [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div></div><!-- fragment --></li>
<li>Pass <code>on_next</code> and <code>on_error</code> handlers: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>)));</div><div class="line">    values.subscribe(</div><div class="line">        [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">        [](std::exception_ptr ep){</div><div class="line">            <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">            <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">            }</div><div class="line">        });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></li>
<li>Pass <code>on_next</code> and <code>on_completed</code> handlers: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3);</div><div class="line">    values.subscribe(</div><div class="line">        [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --></li>
<li>Pass <code>on_next</code>, <code>on_error</code>, and <code>on_completed</code> handlers: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>)));</div><div class="line">    values.subscribe(</div><div class="line">        [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">        [](std::exception_ptr ep){</div><div class="line">            <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">            <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">            }</div><div class="line">        },</div><div class="line">        [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></li>
</ul>
<p>All the alternatives above also support passing <a class="el" href="classrxcpp_1_1composite__subscription.html" title="controls lifetime for scheduler::schedule and observable&lt;T, SourceOperator&gt;::subscribe. ">rxcpp::composite_subscription</a> instance. For example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> subscription = <a class="code" href="classrxcpp_1_1composite__subscription.html">rxcpp::composite_subscription</a>();</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 5);</div><div class="line">    values.subscribe(</div><div class="line">        subscription,</div><div class="line">        [&amp;subscription](<span class="keywordtype">int</span> v){</div><div class="line">            printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);</div><div class="line">            <span class="keywordflow">if</span> (v == 3)</div><div class="line">                subscription.unsubscribe();</div><div class="line">        },</div><div class="line">        [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div></div><!-- fragment --><p> If neither subscription nor subscriber are provided, then a new subscription is created and returned as a result: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::never&lt;int&gt;</a>()).</div><div class="line">        <span class="keywordflow">finally</span>([](){printf(<span class="stringliteral">&quot;The final action\n&quot;</span>);});</div><div class="line">    <span class="keyword">auto</span> subscription = values.subscribe(</div><div class="line">        [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">        [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div><div class="line">    subscription.unsubscribe();</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">The <span class="keyword">final</span> action</div></div><!-- fragment --><p> For more details, see <a class="el" href="namespacerxcpp.html#a242192794ecb4d2fdb69783c5c9fd24f">rxcpp::make_subscriber</a> function description. </p>

</div>
</div>
<a class="anchor" id="a225ad69622b7c80328bae63232de84b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::subscribe_on </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscription and unsubscription are queued and delivered using the scheduler from the supplied coordination. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>the scheduler to perform subscription actions on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The source observable modified so that its subscriptions happen on the specified scheduler.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab6098a8e2412f51c87b01d098278a1e6">map</a>([](<span class="keywordtype">int</span> v){</div><div class="line">            printf(<span class="stringliteral">&quot;[thread %s] Emit value %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">            <span class="keywordflow">return</span> v;</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a225ad69622b7c80328bae63232de84b6">subscribe_on</a>(<a class="code" href="namespacerxcpp.html#ae8b33e61973289899b1cbe1d6a32361d">rxcpp::synchronize_new_thread</a>()).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481313687296] Emit value 1</div><div class="line">[thread 47481313687296] OnNext: 1</div><div class="line">[thread 47481313687296] Emit value 2</div><div class="line">[thread 47481313687296] OnNext: 2</div><div class="line">[thread 47481313687296] Emit value 3</div><div class="line">[thread 47481313687296] OnNext: 3</div><div class="line">[thread 47481313687296] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> Invoking <a class="el" href="classrxcpp_1_1observable.html#abbe2255f4f5b3517d615583ae7085148" title="All values are queued and delivered using the scheduler from the supplied coordination. ">rxcpp::observable::observe_on</a> operator, instead of subscribe_on, gives following results: <div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Emit value 1</div><div class="line">[thread 47481267428736] Emit value 2</div><div class="line">[thread 47481267428736] Emit value 3</div><div class="line">[thread 47481303181056] OnNext: 1</div><div class="line">[thread 47481303181056] OnNext: 2</div><div class="line">[thread 47481303181056] OnNext: 3</div><div class="line">[thread 47481303181056] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a2089aff58d5757a11bd11e10915b5a87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">AN **&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable reduce it by adding to the previous items. </p>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits a single item: the sum of elements emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).sum();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 6</div><div class="line">OnCompleted</div></div><!-- fragment --> When the source observable completes without emitting any items: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;().<a class="code" href="classrxcpp_1_1observable.html#a2089aff58d5757a11bd11e10915b5a87">sum</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1empty__error.html">rxcpp::empty_error</a>&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: <a class="code" href="classrxcpp_1_1observable.html#a2089aff58d5757a11bd11e10915b5a87">sum</a>() requires a stream with at least one value</div></div><!-- fragment --> When the source observable calls on_error: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a2089aff58d5757a11bd11e10915b5a87">sum</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                <span class="keywordflow">try</span> {std::rethrow_exception(ep);}</div><div class="line">                <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a0e261cbdb809940b0248a1fbcbd5ef87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::switch_if_empty </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the source Observable terminates without emitting any items, emits items from a backup Observable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BackupSource</td><td>the type of the backup observable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>a backup observable that is used if the source observable is empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits items from a backup observable if the source observable is empty.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::empty</a>&lt;<span class="keywordtype">int</span>&gt;()</div><div class="line">            .<a class="code" href="classrxcpp_1_1observable.html#a0e261cbdb809940b0248a1fbcbd5ef87">switch_if_empty</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::range</a>(1, 5));</div><div class="line"></div><div class="line">    values.subscribe(</div><div class="line">            [](<span class="keywordtype">int</span> v) { printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v); },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); } );</div><div class="line"></div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnNext: 5</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ae5def992d37a760cec74223df3155525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::switch_on_error </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If an error occurs, take the result from the Selector and subscribe to that instead. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Selector</td><td>the actual type of a function of the form <code>observable&lt;T&gt;(std::exception_ptr)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the function of the form <code>observable&lt;T&gt;(std::exception_ptr)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the items from the source observable and switches to a new observable on error.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a55183eba74706e04b912f592d677f1d8">on_error_resume_next</a>([](std::exception_ptr ep){</div><div class="line">            printf(<span class="stringliteral">&quot;Resuming after: %s\n&quot;</span>, <a class="code" href="namespacerxcpp_1_1util.html#a393c2767bfe9fb7a35297ecb307a7896">rxu::what</a>(ep).c_str());</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="namespacerxcpp_1_1sources.html#a801daa2d18ecb5fb28be86732a40e57a">rxcpp::observable&lt;&gt;::just</a>(-1);</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, <a class="code" href="namespacerxcpp_1_1util.html#a393c2767bfe9fb7a35297ecb307a7896">rxu::what</a>(ep).c_str());</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">Resuming after: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div><div class="line">OnNext: -1</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a47284539a10abb57c63caa6ad05c4b86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::switch_on_next </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return observable that emits the items emitted by the observable most recently emitted by the source observable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cn</td><td>the scheduler to synchronize sources from different contexts (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the items emitted by the observable most recently emitted by the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> base = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(30)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab6098a8e2412f51c87b01d098278a1e6">map</a>([](<span class="keywordtype">long</span>){</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(10)).as_dynamic();</div><div class="line">        });</div><div class="line">    <span class="keyword">auto</span> values = base.switch_on_next().take(10);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a0b375948c452baf1e3854823b7d398de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::take </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the first count items from this observable emit them from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Count</td><td>the type of the items counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the number of items to take.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits only the first t items emitted by the source Observable, or all of the items from the source observable if that observable emits fewer than t items.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).take(3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="acbac14434778d0b139006da8738043dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::take_last </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit only the final t items emitted by the source Observable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Count</td><td>the type of the items counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the number of last items to take.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits only the last t items emitted by the source Observable, or all of the items from the source observable if that observable emits fewer than t items.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).take_last(3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 5</div><div class="line">OnNext: 6</div><div class="line">OnNext: 7</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="acdaecad9e5470ce8acf7f6119ae0d0f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::take_until </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable until on_next occurs on the trigger observable or until the specified time, emit them from the new observable that is returned. take_until takes (TriggerObservable, optional Coordination) or (TimePoint, optional Coordination) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriggerSource</td><td>the type of the trigger observable. </td></tr>
    <tr><td class="paramname">TimePoint</td><td>the type of the time interval. </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>an observable whose first emitted item will stop emitting items from the source observable. </td></tr>
    <tr><td class="paramname">when</td><td>a time point when the returned observable will stop emitting items. </td></tr>
    <tr><td class="paramname">cn</td><td>the scheduler to use for scheduling the items (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits the items emitted by the source observable until trigger observable emitted or the time runs out.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> source = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(10)).take(7);</div><div class="line">    <span class="keyword">auto</span> trigger = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(25));</div><div class="line">    <span class="keyword">auto</span> values = source.take_until(trigger);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> source = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(10)).take(7).map([](<span class="keywordtype">long</span> v){</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source emits, value = %ld\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> trigger = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(25)).map([](<span class="keywordtype">long</span> v){</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Trigger emits, value = %ld\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> values = source.take_until(trigger, <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Source emits, value = 1</div><div class="line">[thread 47481313687296] OnNext: 1</div><div class="line">[thread 47481267428736] Source emits, value = 2</div><div class="line">[thread 47481313687296] OnNext: 2</div><div class="line">[thread 47481267428736] Source emits, value = 3</div><div class="line">[thread 47481313687296] OnNext: 3</div><div class="line">[thread 47481267428736] Trigger emits, value = 1</div><div class="line">[thread 47481313687296] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> source = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(10)).take(7);</div><div class="line">    <span class="keyword">auto</span> values = source.take_until(std::chrono::steady_clock::now() + std::chrono::milliseconds(25));</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;OnNext: %ld\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> source = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(10)).take(7).map([](<span class="keywordtype">long</span> v){</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source emits, value = %ld\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> scheduler = <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>();</div><div class="line">    <span class="keyword">auto</span> values = source.take_until(scheduler.now() + std::chrono::milliseconds(25), scheduler);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %ld\n&quot;</span>, get_pid().c_str(), v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Source emits, value = 1</div><div class="line">[thread 47481313687296] OnNext: 1</div><div class="line">[thread 47481267428736] Source emits, value = 2</div><div class="line">[thread 47481313687296] OnNext: 2</div><div class="line">[thread 47481267428736] Source emits, value = 3</div><div class="line">[thread 47481313687296] OnNext: 3</div><div class="line">[thread 47481313687296] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ac553cf73ea02b79abf5d7db6e60a2cbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::take_while </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the first items fulfilling the predicate from this observable emit them from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>the type of the predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An observable that emits only the first items emitted by the source Observable fulfilling the predicate, or all of the items from the source observable if the predicate never returns false</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 8).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac553cf73ea02b79abf5d7db6e60a2cbb">take_while</a>([](<span class="keywordtype">int</span> v){</div><div class="line">            <span class="keywordflow">return</span> v &lt;= 4;</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 4</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="abf2109684f61f248de266b8df1ad5fbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::tap </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inspect calls to on_next, on_error and on_completed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MakeObserverArgN...</td><td>these args are passed to make_observer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">an</td><td>these args are passed to make_observer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the same items as the source observable to both the subscriber and the observer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an on_error method is not supplied the observer will ignore errors rather than call std::terminate()</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#abf2109684f61f248de266b8df1ad5fbb">tap</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;Tap -       OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;Tap -       OnCompleted\n&quot;</span>);});</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;Subscribe - OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;Subscribe - OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">Tap -       OnNext: 1</div><div class="line">Subscribe - OnNext: 1</div><div class="line">Tap -       OnNext: 2</div><div class="line">Subscribe - OnNext: 2</div><div class="line">Tap -       OnNext: 3</div><div class="line">Subscribe - OnNext: 3</div><div class="line">Tap -       OnCompleted</div><div class="line">Subscribe - OnCompleted</div></div><!-- fragment --> If the source observable generates an error, the observer passed to tap is called: <div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::error&lt;int&gt;</a>(std::runtime_error(<span class="stringliteral">&quot;Error from source&quot;</span>))).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#abf2109684f61f248de266b8df1ad5fbb">tap</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;Tap -       OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                printf(<span class="stringliteral">&quot;Tap -       OnError: %s\n&quot;</span>, <a class="code" href="namespacerxcpp_1_1util.html#a393c2767bfe9fb7a35297ecb307a7896">rxu::what</a>(ep).c_str());</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;Tap -       OnCompleted\n&quot;</span>);});</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;Subscribe - OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](std::exception_ptr ep){</div><div class="line">                printf(<span class="stringliteral">&quot;Subscribe - OnError: %s\n&quot;</span>, <a class="code" href="namespacerxcpp_1_1util.html#a393c2767bfe9fb7a35297ecb307a7896">rxu::what</a>(ep).c_str());</div><div class="line">            },</div><div class="line">            [](){printf(<span class="stringliteral">&quot;Subscribe - OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">Tap -       OnNext: 1</div><div class="line">Subscribe - OnNext: 1</div><div class="line">Tap -       OnNext: 2</div><div class="line">Subscribe - OnNext: 2</div><div class="line">Tap -       OnNext: 3</div><div class="line">Subscribe - OnNext: 3</div><div class="line">Tap -       OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div><div class="line">Subscribe - OnError: Error <a class="code" href="namespacecpplinq.html#ab6ee360fdae8a4a20e14cb260eb4cec2">from</a> source</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a72044b2d3e68179cc88379173edb24f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::time_interval </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an observable that emits indications of the amount of time lapsed between consecutive emissions of the source observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordination</td><td>the scheduler for time intervals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits a time_duration to indicate the amount of time lapsed between pairs of emissions.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">typedef</span> rxcpp::schedulers::scheduler::clock_type::time_point::duration duration_type;</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>std::chrono;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(milliseconds(100))</div><div class="line">            .time_interval()</div><div class="line">            .take(3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;](duration_type v) {</div><div class="line">                <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> ms = duration_cast&lt;milliseconds&gt;(v).<a class="code" href="classrxcpp_1_1observable.html#ad9451593d64584ef6c80f74d04d1c8d4">count</a>();</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext: @%lldms\n&quot;</span>, ms);</div><div class="line">            },</div><div class="line">            [](std::exception_ptr ep) {</div><div class="line">                <span class="keywordflow">try</span> {</div><div class="line">                    std::rethrow_exception(ep);</div><div class="line">                } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: @0ms</div><div class="line">OnNext: @100ms</div><div class="line">OnNext: @100ms</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="ac18651c2dbe6c603e6f7f53389ee4176"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::timeout </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that terminates with <a class="el" href="classrxcpp_1_1timeout__error.html">timeout_error</a> if a particular timespan has passed without emitting another item from the source observable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of time interval. </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the period of time wait for another item from the source observable. </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler to manage timeout for each event (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that terminates with an error if a particular timespan has passed without emitting another item from the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>std::chrono;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(milliseconds(100))</div><div class="line">            .take(3)</div><div class="line">            .concat(<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::interval</a>(milliseconds(500)))</div><div class="line">            .timeout(milliseconds(200));</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">long</span> v) { printf(<span class="stringliteral">&quot;OnNext: %ld\n&quot;</span>, v); },</div><div class="line">            [](std::exception_ptr ep) {</div><div class="line">                <span class="keywordflow">try</span> {</div><div class="line">                    std::rethrow_exception(ep);</div><div class="line">                } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classrxcpp_1_1timeout__error.html">rxcpp::timeout_error</a>&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1</div><div class="line">OnNext: 2</div><div class="line">OnNext: 3</div><div class="line">OnNext: 1</div><div class="line">OnError: <a class="code" href="classrxcpp_1_1observable.html#ac18651c2dbe6c603e6f7f53389ee4176">timeout</a> has occurred</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a5b3dcda85c609a5006fa1707da5ae3d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::timestamp </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an observable that attaches a timestamp to each item emitted by the source observable indicating when it was emitted. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordination</td><td>the scheduler to manage timeout for each event (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits a pair: { item emitted by the source observable, time_point representing the current value of the clock }.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">typedef</span> rxcpp::schedulers::scheduler::clock_type::time_point time_point;</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>std::chrono;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(milliseconds(100))</div><div class="line">            .timestamp()</div><div class="line">            .take(3);</div><div class="line">    time_point start = <a class="code" href="namespacerxcpp.html#a50575b7f31a42160e1b5a2f6c6c5827c">rxcpp::identity_current_thread</a>().<a class="code" href="classrxcpp_1_1identity__one__worker.html#a71a66639f6f72a111ad20e9a90d6a1c5">now</a>();</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;](std::pair&lt;long, time_point&gt; v) { </div><div class="line">                <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> ms = duration_cast&lt;milliseconds&gt;(v.second - start).<a class="code" href="classrxcpp_1_1observable.html#ad9451593d64584ef6c80f74d04d1c8d4">count</a>();</div><div class="line">                printf(<span class="stringliteral">&quot;OnNext: %ld @%lldms\n&quot;</span>, v.first, ms); </div><div class="line">            },</div><div class="line">            [](std::exception_ptr ep) {</div><div class="line">                <span class="keywordflow">try</span> {</div><div class="line">                    std::rethrow_exception(ep);</div><div class="line">                } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div><div class="line">                    printf(<span class="stringliteral">&quot;OnError: %s\n&quot;</span>, ex.what());</div><div class="line">                }</div><div class="line">            },</div><div class="line">            []() { printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>); });</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1 @0ms</div><div class="line">OnNext: 2 @100ms</div><div class="line">OnNext: 3 @200ms</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a284866ee1ffad7f10a006922ca7f41fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from this observable use Selector to produce an item to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Selector</td><td>the type of the transforming function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the selector function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the items from the source observable, transformed by the specified function.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ab6098a8e2412f51c87b01d098278a1e6">map</a>([](<span class="keywordtype">int</span> v){</div><div class="line">            <span class="keywordflow">return</span> 2 * v;</div><div class="line">        });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 2</div><div class="line">OnNext: 4</div><div class="line">OnNext: 6</div><div class="line">OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="aca631f7a8a5c197c825c6d4281ac6a3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::window </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits connected, non-overlapping windows, each containing at most count items from the source observable. If the skip parameter is set, return an observable that emits windows every skip items containing at most count items from the source observable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the maximum size of each window before it should be completed </td></tr>
    <tr><td class="paramname">skip</td><td>how many items need to be skipped before starting a new window</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits connected, non-overlapping windows, each containing at most count items from the source observable. If the skip parameter is set, return an Observable that emits windows every skip items containing at most count items from the source observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 7).window(2, 3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;int&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %d\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 4</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 5</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 7</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1, 5).window(2);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;int&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %d\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 3</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 4</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 5</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a87c299105748ab694bb3decc83f2b02d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::window_toggle </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits observables every period time interval and collects items from this observable for period of time into each produced observable, on the specified scheduler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Openings</td><td>observable&lt;OT&gt; </td></tr>
    <tr><td class="paramname">ClosingSelector</td><td>a function of type observable&lt;CT&gt;(OT) </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opens</td><td>each value from this observable opens a new window. </td></tr>
    <tr><td class="paramname">closes</td><td>this function is called for each opened window and returns an observable. the first value from the returned observable will close the window. </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler for the windows (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits an observable for each opened window.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a87c299105748ab694bb3decc83f2b02d">window_toggle</a>(</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(4)), </div><div class="line">            [](<span class="keywordtype">long</span>){</div><div class="line">                <span class="keywordflow">return</span> <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(4)).skip(1);</div><div class="line">            },</div><div class="line">            <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;long&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %ld\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 3</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 4</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 5</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 6</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnNext: 7</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a87c299105748ab694bb3decc83f2b02d">window_toggle</a>(</div><div class="line">            <a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(4)), </div><div class="line">            [](<span class="keywordtype">long</span>){</div><div class="line">                <span class="keywordflow">return</span> <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(4)).skip(1);</div><div class="line">            });</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;long&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %ld\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 3</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 4</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 5</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 6</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnNext: 7</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a156fe8c091615a81f153266cf2288e00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::window_with_time </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits observables every period time interval and collects items from this observable for period of time into each produced observable, on the specified scheduler. If the skip parameter is set, return an observable that emits observables every skip time interval and collects items from this observable for period of time into each produced observable, on the specified scheduler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of time intervals. </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the period of time each window collects items before it is completed. </td></tr>
    <tr><td class="paramname">skip</td><td>the period of time after which a new window will be created. </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler for the windows (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits observables every period time interval and collect items from this observable for period of time into each produced observable. If the skip parameter is set, return an Observable that emits observables every skip time interval and collect items from this observable for period of time into each produced observable.</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> period = std::chrono::milliseconds(4);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a> = std::chrono::milliseconds(6);</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a156fe8c091615a81f153266cf2288e00">window_with_time</a>(period, <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a>, <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;long&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %ld\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 4</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 5</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 7</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> period = std::chrono::milliseconds(4);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a> = std::chrono::milliseconds(6);</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a156fe8c091615a81f153266cf2288e00">window_with_time</a>(period, <a class="code" href="classrxcpp_1_1observable.html#a5283adf7187df741a8a22d7bd73d270a">skip</a>);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;long&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %ld\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 4</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 5</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 7</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a156fe8c091615a81f153266cf2288e00">window_with_time</a>(std::chrono::milliseconds(4), <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;long&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %ld\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 3</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 4</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 5</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 6</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnNext: 7</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> values = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::steady_clock::now() + std::chrono::milliseconds(1), std::chrono::milliseconds(2)).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(7).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a156fe8c091615a81f153266cf2288e00">window_with_time</a>(std::chrono::milliseconds(4));</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;long&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %ld\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 3</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 4</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 5</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnNext: 6</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnNext: 7</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="acd61243ac469723f00c88827ed94f43f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::window_with_time_or_count </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an observable that emits connected, non-overlapping windows of items from the source observable that were emitted during a fixed duration of time or when the window has reached maximum capacity (whichever occurs first), on the specified scheduler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>the type of time intervals. </td></tr>
    <tr><td class="paramname">Coordination</td><td>the type of the scheduler (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the period of time each window collects items before it is completed and replaced with a new window. </td></tr>
    <tr><td class="paramname">count</td><td>the maximum size of each window before it is completed and new window is created. </td></tr>
    <tr><td class="paramname">coordination</td><td>the scheduler for the windows (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits connected, non-overlapping windows of items from the source observable that were emitted during a fixed duration of time or when the window has reached maximum capacity (whichever occurs first).</dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> int1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1L, 3L);</div><div class="line">    <span class="keyword">auto</span> int2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(50));</div><div class="line">    <span class="keyword">auto</span> values = int1.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(int2).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#acd61243ac469723f00c88827ed94f43f">window_with_time_or_count</a>(std::chrono::milliseconds(20), 2, <a class="code" href="namespacerxcpp.html#abada901083087bcaa013508558643f41">rxcpp::observe_on_event_loop</a>());</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;long&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %ld\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 3</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnCompleted</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Sample Code</dt><dd><div class="fragment"><div class="line">    <span class="keywordtype">int</span> counter = 0;</div><div class="line">    <span class="keyword">auto</span> int1 = <a class="code" href="namespacerxcpp_1_1sources.html#a5b76c2ddb8291eb88060caa818bab729">rxcpp::observable&lt;&gt;::range</a>(1L, 3L);</div><div class="line">    <span class="keyword">auto</span> int2 = <a class="code" href="namespacerxcpp_1_1sources.html#a716d00db20fa06c1b3bfb95631c52547">rxcpp::observable&lt;&gt;::timer</a>(std::chrono::milliseconds(50));</div><div class="line">    <span class="keyword">auto</span> values = int1.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a3041ca26a53f2912dd15cde6e3422d07">concat</a>(int2).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#acd61243ac469723f00c88827ed94f43f">window_with_time_or_count</a>(std::chrono::milliseconds(20), 2);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [&amp;counter](<a class="code" href="classrxcpp_1_1observable.html">rxcpp::observable&lt;long&gt;</a> v){</div><div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = counter++;</div><div class="line">                printf(<span class="stringliteral">&quot;[window %d] Create window\n&quot;</span>, <span class="keywordtype">id</span>);</div><div class="line">                v.<a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">                    [<span class="keywordtype">id</span>](<span class="keywordtype">long</span> v){printf(<span class="stringliteral">&quot;[window %d] OnNext: %ld\n&quot;</span>, <span class="keywordtype">id</span>, v);},</div><div class="line">                    [id](){printf(<span class="stringliteral">&quot;[window %d] OnCompleted\n&quot;</span>, <span class="keywordtype">id</span>);});</div><div class="line">            });</div></div><!-- fragment --><div class="fragment"><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnNext: 2</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 0] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnNext: 3</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 1] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 2] OnCompleted</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] Create <a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a></div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnNext: 1</div><div class="line">[<a class="code" href="classrxcpp_1_1observable.html#aca631f7a8a5c197c825c6d4281ac6a3e">window</a> 3] OnCompleted</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a class="anchor" id="a43608a25beb6e2612429f063fb8a768b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::with_latest_from </td>
          <td>(</td>
          <td class="paramtype">AN...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each item from the first observable select the latest value from all the observables to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AN</td><td>types of scheduler (optional), aggregate function (optional), and source observables</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">an</td><td>scheduler (optional), aggregation function (optional), and source observables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits items that are the result of combining the items emitted by the source observables.</dd></dl>
<p>If scheduler is omitted, identity_current_thread is used.</p>
<p>If aggregation function is omitted, the resulting observable returns tuples of emitted items.</p>
<dl class="section user"><dt>Sample Code</dt><dd></dd></dl>
<p>Neither scheduler nor aggregation function are present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(5));</div><div class="line">    <span class="keyword">auto</span> values = o1.with_latest_from(o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, int, int&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d, %d, %d\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v), std::get&lt;2&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 2, 1, 1</div><div class="line">OnNext: 3, 2, 1</div><div class="line">OnNext: 4, 2, 2</div><div class="line">OnNext: 5, 3, 2</div><div class="line">OnNext: 6, 4, 2</div><div class="line">OnCompleted</div></div><!-- fragment --><p> Only scheduler is present: </p><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> thr = <a class="code" href="namespacerxcpp.html#a17a3a0a2d399be2c32f41f929e740c67">rxcpp::synchronize_event_loop</a>();</div><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source1 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source2 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(5)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source3 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> values = o1.with_latest_from(thr, o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, int, int&gt; v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d, %d, %d\n&quot;</span>, get_pid().c_str(), std::get&lt;0&gt;(v), std::get&lt;1&gt;(v), std::get&lt;2&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Source1 OnNext: 1</div><div class="line">[thread 47481267428736] Source2 OnNext: 1</div><div class="line">[thread 47481267428736] Source3 OnNext: 1</div><div class="line">[thread 47481267428736] Source1 OnNext: 2</div><div class="line">[thread 47481294776064] OnNext: 2, 1, 1</div><div class="line">[thread 47481267428736] Source2 OnNext: 2</div><div class="line">[thread 47481267428736] Source1 OnNext: 3</div><div class="line">[thread 47481294776064] OnNext: 3, 2, 1</div><div class="line">[thread 47481267428736] Source3 OnNext: 2</div><div class="line">[thread 47481267428736] Source1 OnNext: 4</div><div class="line">[thread 47481267428736] Source2 OnNext: 3</div><div class="line">[thread 47481294776064] OnNext: 4, 2, 2</div><div class="line">[thread 47481267428736] Source1 OnNext: 5</div><div class="line">[thread 47481294776064] OnNext: 5, 3, 2</div><div class="line">[thread 47481267428736] Source2 OnNext: 4</div><div class="line">[thread 47481267428736] Source1 OnNext: 6</div><div class="line">[thread 47481267428736] Source3 OnNext: 3</div><div class="line">[thread 47481294776064] OnNext: 6, 4, 2</div><div class="line">[thread 47481294776064] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --><p> Only aggregation function is present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(5));</div><div class="line">    <span class="keyword">auto</span> values = o1.with_latest_from(</div><div class="line">        [](<span class="keywordtype">int</span> v1, <span class="keywordtype">int</span> v2, <span class="keywordtype">int</span> v3) {</div><div class="line">            <span class="keywordflow">return</span> 100 * v1 + 10 * v2 + v3;</div><div class="line">        },</div><div class="line">        o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 211</div><div class="line">OnNext: 321</div><div class="line">OnNext: 422</div><div class="line">OnNext: 532</div><div class="line">OnNext: 642</div><div class="line">OnCompleted</div></div><!-- fragment --><p> Both scheduler and aggregation function are present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(5));</div><div class="line">    <span class="keyword">auto</span> values = o1.with_latest_from(</div><div class="line">        <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>(),</div><div class="line">        [](<span class="keywordtype">int</span> v1, <span class="keywordtype">int</span> v2, <span class="keywordtype">int</span> v3) {</div><div class="line">            <span class="keywordflow">return</span> 100 * v1 + 10 * v2 + v3;</div><div class="line">        },</div><div class="line">        o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(5).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 211</div><div class="line">OnNext: 321</div><div class="line">OnNext: 422</div><div class="line">OnNext: 532</div><div class="line">OnNext: 642</div><div class="line">OnCompleted</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a883540dae084f6c0aff3c5396448d4ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class... AN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::zip </td>
          <td>(</td>
          <td class="paramtype">AN &amp;&amp;...&#160;</td>
          <td class="paramname"><em>an</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bring by one item from all given observables and select a value to emit from the new observable that is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AN</td><td>types of scheduler (optional), aggregate function (optional), and source observables</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">an</td><td>scheduler (optional), aggregation function (optional), and source observables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Observable that emits the result of combining the items emitted and brought by one from each of the source observables.</dd></dl>
<p>If scheduler is omitted, identity_current_thread is used.</p>
<p>If aggregation function is omitted, the resulting observable returns tuples of emitted items.</p>
<dl class="section user"><dt>Sample Code</dt><dd></dd></dl>
<p>Neither scheduler nor aggregation function are present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(1));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> values = o1.zip(o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, int, int&gt; v){printf(<span class="stringliteral">&quot;OnNext: %d, %d, %d\n&quot;</span>, std::get&lt;0&gt;(v), std::get&lt;1&gt;(v), std::get&lt;2&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 1, 1, 1</div><div class="line">OnNext: 2, 2, 2</div><div class="line">OnNext: 3, 3, 3</div><div class="line">OnCompleted</div></div><!-- fragment --><p> Only scheduler is present: </p><div class="fragment"><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Start task\n&quot;</span>, get_pid().c_str());</div><div class="line">    <span class="keyword">auto</span> thr = <a class="code" href="namespacerxcpp.html#a17a3a0a2d399be2c32f41f929e740c67">rxcpp::synchronize_event_loop</a>();</div><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(1)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source1 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source2 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3)).map([](<span class="keywordtype">int</span> v) {</div><div class="line">        printf(<span class="stringliteral">&quot;[thread %s] Source3 OnNext: %d\n&quot;</span>, get_pid().c_str(), v);</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    });</div><div class="line">    <span class="keyword">auto</span> values = o1.zip(thr, o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](std::tuple&lt;int, int, int&gt; v){printf(<span class="stringliteral">&quot;[thread %s] OnNext: %d, %d, %d\n&quot;</span>, get_pid().c_str(), std::get&lt;0&gt;(v), std::get&lt;1&gt;(v), std::get&lt;2&gt;(v));},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;[thread %s] OnCompleted\n&quot;</span>, get_pid().c_str());});</div><div class="line">    printf(<span class="stringliteral">&quot;[thread %s] Finish task\n&quot;</span>, get_pid().c_str());</div></div><!-- fragment --><div class="fragment"><div class="line">[thread 47481267428736] Start task</div><div class="line">[thread 47481267428736] Source1 OnNext: 1</div><div class="line">[thread 47481267428736] Source2 OnNext: 1</div><div class="line">[thread 47481267428736] Source3 OnNext: 1</div><div class="line">[thread 47481298978560] OnNext: 1, 1, 1</div><div class="line">[thread 47481267428736] Source1 OnNext: 2</div><div class="line">[thread 47481267428736] Source1 OnNext: 3</div><div class="line">[thread 47481267428736] Source2 OnNext: 2</div><div class="line">[thread 47481267428736] Source1 OnNext: 4</div><div class="line">[thread 47481267428736] Source3 OnNext: 2</div><div class="line">[thread 47481298978560] OnNext: 2, 2, 2</div><div class="line">[thread 47481267428736] Source1 OnNext: 5</div><div class="line">[thread 47481267428736] Source2 OnNext: 3</div><div class="line">[thread 47481267428736] Source1 OnNext: 6</div><div class="line">[thread 47481267428736] Source1 OnNext: 7</div><div class="line">[thread 47481267428736] Source2 OnNext: 4</div><div class="line">[thread 47481267428736] Source3 OnNext: 3</div><div class="line">[thread 47481298978560] OnNext: 3, 3, 3</div><div class="line">[thread 47481298978560] OnCompleted</div><div class="line">[thread 47481267428736] Finish task</div></div><!-- fragment --><p> Only aggregation function is present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(1));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> values = o1 | <a class="code" href="namespacerxcpp_1_1operators.html#a4b4ca255d7fd329b656d1470621178e2">rxcpp::operators::zip</a>(</div><div class="line">        [](<span class="keywordtype">int</span> v1, <span class="keywordtype">int</span> v2, <span class="keywordtype">int</span> v3) {</div><div class="line">            <span class="keywordflow">return</span> 100 * v1 + 10 * v2 + v3;</div><div class="line">        },</div><div class="line">        o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 111</div><div class="line">OnNext: 222</div><div class="line">OnNext: 333</div><div class="line">OnCompleted</div></div><!-- fragment --><p> Both scheduler and aggregation function are present: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> o1 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(1));</div><div class="line">    <span class="keyword">auto</span> o2 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(2));</div><div class="line">    <span class="keyword">auto</span> o3 = <a class="code" href="namespacerxcpp_1_1sources.html#a82199f9611daeb1dcc4552a7e03de01a">rxcpp::observable&lt;&gt;::interval</a>(std::chrono::milliseconds(3));</div><div class="line">    <span class="keyword">auto</span> values = o1.zip(</div><div class="line">        <a class="code" href="namespacerxcpp.html#a863e4ffce9227c2a5c06d025cd232b4d">rxcpp::observe_on_new_thread</a>(),</div><div class="line">        [](<span class="keywordtype">int</span> v1, <span class="keywordtype">int</span> v2, <span class="keywordtype">int</span> v3) {</div><div class="line">            <span class="keywordflow">return</span> 100 * v1 + 10 * v2 + v3;</div><div class="line">        },</div><div class="line">        o2, o3);</div><div class="line">    values.</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#a0b375948c452baf1e3854823b7d398de">take</a>(3).</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#ac2ef8a400c97f4a9a0827abede3af526">as_blocking</a>().</div><div class="line">        <a class="code" href="classrxcpp_1_1observable.html#aee091cb373e1c0d392b2b2d208cedfda">subscribe</a>(</div><div class="line">            [](<span class="keywordtype">int</span> v){printf(<span class="stringliteral">&quot;OnNext: %d\n&quot;</span>, v);},</div><div class="line">            [](){printf(<span class="stringliteral">&quot;OnCompleted\n&quot;</span>);});</div></div><!-- fragment --><div class="fragment"><div class="line">OnNext: 111</div><div class="line">OnNext: 222</div><div class="line">OnNext: 333</div><div class="line">OnCompleted</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="acc2477d3e61a348c9d584e655cdefc7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class U , class SO &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classrxcpp_1_1observable.html">observable</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9b848fa96296bc6772e673cba3869f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<div class="memtemplate">
template&lt;class U , class SO &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; U, SO &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrxcpp_1_1observable.html">observable</a>&lt; U, SO &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7b75fd3cc1b1a2885ac04abaf9b9733b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class SourceOperator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrxcpp_1_1observable.html#acc65011f4be0645074fce6e3ffa55183">source_operator_type</a> <a class="el" href="classrxcpp_1_1observable.html">rxcpp::observable</a>&lt; T, SourceOperator &gt;::source_operator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/Reactive-Extensions/RxCpp/Rx/v2/src/rxcpp/<a class="el" href="rx-observable_8hpp_source.html">rx-observable.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 26 2017 23:15:57 for RxCpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-60804833-2', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
